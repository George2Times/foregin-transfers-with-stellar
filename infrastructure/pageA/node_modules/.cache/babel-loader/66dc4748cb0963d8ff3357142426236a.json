{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar randombytes_1 = tslib_1.__importDefault(require(\"randombytes\"));\n\nvar stellar_base_1 = require(\"stellar-base\");\n\nvar errors_1 = require(\"./errors\");\n\nvar Utils;\n\n(function (Utils) {\n  function buildChallengeTx(serverKeypair, clientAccountID, anchorName, timeout, networkPassphrase) {\n    if (timeout === void 0) {\n      timeout = 300;\n    }\n\n    var account = new stellar_base_1.Account(serverKeypair.publicKey(), \"-1\");\n    var now = Math.floor(Date.now() / 1000);\n    var value = randombytes_1.default(48).toString(\"base64\");\n    var transaction = new stellar_base_1.TransactionBuilder(account, {\n      fee: stellar_base_1.BASE_FEE,\n      networkPassphrase: networkPassphrase,\n      timebounds: {\n        minTime: now,\n        maxTime: now + timeout\n      }\n    }).addOperation(stellar_base_1.Operation.manageData({\n      name: anchorName + \" auth\",\n      value: value,\n      source: clientAccountID\n    })).build();\n    transaction.sign(serverKeypair);\n    return transaction.toEnvelope().toXDR(\"base64\").toString();\n  }\n\n  Utils.buildChallengeTx = buildChallengeTx;\n\n  function verifyChallengeTx(challengeTx, serverAccountId, networkPassphrase) {\n    var transaction = new stellar_base_1.Transaction(challengeTx, networkPassphrase);\n    var sequence = Number.parseInt(transaction.sequence, 10);\n\n    if (sequence !== 0) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction sequence number should be zero\");\n    }\n\n    if (transaction.source !== serverAccountId) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction source account is not equal to the server's account\");\n    }\n\n    if (transaction.operations.length !== 1) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction should contain only one operation\");\n    }\n\n    var operation = transaction.operations[0];\n\n    if (!operation.source) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation should contain a source account\");\n    }\n\n    if (operation.type !== \"manageData\") {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation should be manageData\");\n    }\n\n    if (Buffer.from(operation.value.toString(), \"base64\").length !== 48) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation value should be a 64 bytes base64 random string\");\n    }\n\n    if (!verifyTxSignedBy(transaction, serverAccountId)) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction is not signed by the server\");\n    }\n\n    if (!verifyTxSignedBy(transaction, operation.source)) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction is not signed by the client\");\n    }\n\n    if (!validateTimebounds(transaction)) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction has expired\");\n    }\n\n    return true;\n  }\n\n  Utils.verifyChallengeTx = verifyChallengeTx;\n\n  function verifyTxSignedBy(transaction, accountId) {\n    var hashedSignatureBase = transaction.hash();\n    var keypair = stellar_base_1.Keypair.fromPublicKey(accountId);\n    return !!transaction.signatures.find(function (sig) {\n      return keypair.verify(hashedSignatureBase, sig.signature());\n    });\n  }\n\n  Utils.verifyTxSignedBy = verifyTxSignedBy;\n\n  function validateTimebounds(transaction) {\n    if (!transaction.timeBounds) {\n      return false;\n    }\n\n    var now = Math.floor(Date.now() / 1000);\n    var _a = transaction.timeBounds,\n        minTime = _a.minTime,\n        maxTime = _a.maxTime;\n    return now >= Number.parseInt(minTime, 10) && now <= Number.parseInt(maxTime, 10);\n  }\n})(Utils = exports.Utils || (exports.Utils = {}));","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar randombytes_1 = tslib_1.__importDefault(require(\"randombytes\"));\nvar stellar_base_1 = require(\"stellar-base\");\nvar errors_1 = require(\"./errors\");\nvar Utils;\n(function (Utils) {\n    function buildChallengeTx(serverKeypair, clientAccountID, anchorName, timeout, networkPassphrase) {\n        if (timeout === void 0) { timeout = 300; }\n        var account = new stellar_base_1.Account(serverKeypair.publicKey(), \"-1\");\n        var now = Math.floor(Date.now() / 1000);\n        var value = randombytes_1.default(48).toString(\"base64\");\n        var transaction = new stellar_base_1.TransactionBuilder(account, {\n            fee: stellar_base_1.BASE_FEE,\n            networkPassphrase: networkPassphrase,\n            timebounds: {\n                minTime: now,\n                maxTime: now + timeout,\n            },\n        })\n            .addOperation(stellar_base_1.Operation.manageData({\n            name: anchorName + \" auth\",\n            value: value,\n            source: clientAccountID,\n        }))\n            .build();\n        transaction.sign(serverKeypair);\n        return transaction\n            .toEnvelope()\n            .toXDR(\"base64\")\n            .toString();\n    }\n    Utils.buildChallengeTx = buildChallengeTx;\n    function verifyChallengeTx(challengeTx, serverAccountId, networkPassphrase) {\n        var transaction = new stellar_base_1.Transaction(challengeTx, networkPassphrase);\n        var sequence = Number.parseInt(transaction.sequence, 10);\n        if (sequence !== 0) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction sequence number should be zero\");\n        }\n        if (transaction.source !== serverAccountId) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction source account is not equal to the server's account\");\n        }\n        if (transaction.operations.length !== 1) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction should contain only one operation\");\n        }\n        var operation = transaction.operations[0];\n        if (!operation.source) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation should contain a source account\");\n        }\n        if (operation.type !== \"manageData\") {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation should be manageData\");\n        }\n        if (Buffer.from(operation.value.toString(), \"base64\").length !== 48) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation value should be a 64 bytes base64 random string\");\n        }\n        if (!verifyTxSignedBy(transaction, serverAccountId)) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction is not signed by the server\");\n        }\n        if (!verifyTxSignedBy(transaction, operation.source)) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction is not signed by the client\");\n        }\n        if (!validateTimebounds(transaction)) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction has expired\");\n        }\n        return true;\n    }\n    Utils.verifyChallengeTx = verifyChallengeTx;\n    function verifyTxSignedBy(transaction, accountId) {\n        var hashedSignatureBase = transaction.hash();\n        var keypair = stellar_base_1.Keypair.fromPublicKey(accountId);\n        return !!transaction.signatures.find(function (sig) {\n            return keypair.verify(hashedSignatureBase, sig.signature());\n        });\n    }\n    Utils.verifyTxSignedBy = verifyTxSignedBy;\n    function validateTimebounds(transaction) {\n        if (!transaction.timeBounds) {\n            return false;\n        }\n        var now = Math.floor(Date.now() / 1000);\n        var _a = transaction.timeBounds, minTime = _a.minTime, maxTime = _a.maxTime;\n        return (now >= Number.parseInt(minTime, 10) && now <= Number.parseInt(maxTime, 10));\n    }\n})(Utils = exports.Utils || (exports.Utils = {}));\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}