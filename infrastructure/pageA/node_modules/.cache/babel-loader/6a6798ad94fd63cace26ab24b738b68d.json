{"ast":null,"code":"'use strict'; // vendored from http://cryptocoinjs.com/modules/misc/bs58/\n// Base58 encoding/decoding\n// Originally written by Mike Hearn for BitcoinJ\n// Copyright (c) 2011 Google Inc\n// Ported to JavaScript by Stefan Thomas\n// Merged Buffer refactorings from base58-native by Stephen Pair\n// Copyright (c) 2013 BitPay Inc\n\nvar ALPHABET = 'gsphnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCr65jkm8oFqi1tuvAxyz';\nvar ALPHABET_MAP = {};\n\nfor (var i = 0; i < ALPHABET.length; ++i) {\n  ALPHABET_MAP[ALPHABET.charAt(i)] = i;\n}\n\nvar BASE = 58;\n\nfunction decode(string) {\n  if (string.length === 0) return [];\n  var i,\n      j,\n      bytes = [0];\n\n  for (i = 0; i < string.length; ++i) {\n    var c = string[i];\n    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');\n\n    for (j = 0; j < bytes.length; ++j) {\n      bytes[j] *= BASE;\n    }\n\n    bytes[0] += ALPHABET_MAP[c];\n    var carry = 0;\n\n    for (j = 0; j < bytes.length; ++j) {\n      bytes[j] += carry;\n      carry = bytes[j] >> 8;\n      bytes[j] &= 0xff;\n    }\n\n    while (carry) {\n      bytes.push(carry & 0xff);\n      carry >>= 8;\n    }\n  } // deal with leading zeros\n\n\n  for (i = 0; string[i] === 'g' && i < string.length - 1; ++i) {\n    bytes.push(0);\n  }\n\n  return bytes.reverse();\n}\n\nmodule.exports = {\n  decode: decode\n};","map":{"version":3,"sources":["/home/azureuser/foregin-transfers-with-stellar/infrastructure/pageA/node_modules/stellar-base/lib/vendor/bs58.js"],"names":["ALPHABET","ALPHABET_MAP","i","length","charAt","BASE","decode","string","j","bytes","c","Error","carry","push","reverse","module","exports"],"mappings":"AAAA,a,CAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,QAAQ,GAAG,4DAAf;AACA,IAAIC,YAAY,GAAG,EAAnB;;AACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACG,MAA7B,EAAqC,EAAED,CAAvC,EAA0C;AACxCD,EAAAA,YAAY,CAACD,QAAQ,CAACI,MAAT,CAAgBF,CAAhB,CAAD,CAAZ,GAAmCA,CAAnC;AACD;;AACD,IAAIG,IAAI,GAAG,EAAX;;AAEA,SAASC,MAAT,CAAgBC,MAAhB,EAAwB;AACtB,MAAIA,MAAM,CAACJ,MAAP,KAAkB,CAAtB,EAAyB,OAAO,EAAP;AAEzB,MAAID,CAAJ;AAAA,MACIM,CADJ;AAAA,MAEIC,KAAK,GAAG,CAAC,CAAD,CAFZ;;AAGA,OAAKP,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGK,MAAM,CAACJ,MAAvB,EAA+B,EAAED,CAAjC,EAAoC;AAClC,QAAIQ,CAAC,GAAGH,MAAM,CAACL,CAAD,CAAd;AACA,QAAI,EAAEQ,CAAC,IAAIT,YAAP,CAAJ,EAA0B,MAAM,IAAIU,KAAJ,CAAU,sBAAV,CAAN;;AAE1B,SAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,KAAK,CAACN,MAAtB,EAA8B,EAAEK,CAAhC,EAAmC;AACjCC,MAAAA,KAAK,CAACD,CAAD,CAAL,IAAYH,IAAZ;AACD;;AAAAI,IAAAA,KAAK,CAAC,CAAD,CAAL,IAAYR,YAAY,CAACS,CAAD,CAAxB;AAED,QAAIE,KAAK,GAAG,CAAZ;;AACA,SAAKJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,KAAK,CAACN,MAAtB,EAA8B,EAAEK,CAAhC,EAAmC;AACjCC,MAAAA,KAAK,CAACD,CAAD,CAAL,IAAYI,KAAZ;AAEAA,MAAAA,KAAK,GAAGH,KAAK,CAACD,CAAD,CAAL,IAAY,CAApB;AACAC,MAAAA,KAAK,CAACD,CAAD,CAAL,IAAY,IAAZ;AACD;;AAED,WAAOI,KAAP,EAAc;AACZH,MAAAA,KAAK,CAACI,IAAN,CAAWD,KAAK,GAAG,IAAnB;AAEAA,MAAAA,KAAK,KAAK,CAAV;AACD;AACF,GA3BqB,CA6BtB;;;AACA,OAAKV,CAAC,GAAG,CAAT,EAAYK,MAAM,CAACL,CAAD,CAAN,KAAc,GAAd,IAAqBA,CAAC,GAAGK,MAAM,CAACJ,MAAP,GAAgB,CAArD,EAAwD,EAAED,CAA1D,EAA6D;AAC3DO,IAAAA,KAAK,CAACI,IAAN,CAAW,CAAX;AACD;;AAAA,SAAOJ,KAAK,CAACK,OAAN,EAAP;AACF;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AAAEV,EAAAA,MAAM,EAAEA;AAAV,CAAjB","sourcesContent":["'use strict';\n\n// vendored from http://cryptocoinjs.com/modules/misc/bs58/\n\n// Base58 encoding/decoding\n// Originally written by Mike Hearn for BitcoinJ\n// Copyright (c) 2011 Google Inc\n// Ported to JavaScript by Stefan Thomas\n// Merged Buffer refactorings from base58-native by Stephen Pair\n// Copyright (c) 2013 BitPay Inc\n\nvar ALPHABET = 'gsphnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCr65jkm8oFqi1tuvAxyz';\nvar ALPHABET_MAP = {};\nfor (var i = 0; i < ALPHABET.length; ++i) {\n  ALPHABET_MAP[ALPHABET.charAt(i)] = i;\n}\nvar BASE = 58;\n\nfunction decode(string) {\n  if (string.length === 0) return [];\n\n  var i,\n      j,\n      bytes = [0];\n  for (i = 0; i < string.length; ++i) {\n    var c = string[i];\n    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');\n\n    for (j = 0; j < bytes.length; ++j) {\n      bytes[j] *= BASE;\n    }bytes[0] += ALPHABET_MAP[c];\n\n    var carry = 0;\n    for (j = 0; j < bytes.length; ++j) {\n      bytes[j] += carry;\n\n      carry = bytes[j] >> 8;\n      bytes[j] &= 0xff;\n    }\n\n    while (carry) {\n      bytes.push(carry & 0xff);\n\n      carry >>= 8;\n    }\n  }\n\n  // deal with leading zeros\n  for (i = 0; string[i] === 'g' && i < string.length - 1; ++i) {\n    bytes.push(0);\n  }return bytes.reverse();\n}\n\nmodule.exports = { decode: decode };"]},"metadata":{},"sourceType":"script"}