{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.isValidDate = isValidDate;\n\nvar _jsXdr = require('js-xdr');\n\nvar _bignumber = require('bignumber.js');\n\nvar _bignumber2 = _interopRequireDefault(_bignumber);\n\nvar _clone = require('lodash/clone');\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _isUndefined = require('lodash/isUndefined');\n\nvar _isUndefined2 = _interopRequireDefault(_isUndefined);\n\nvar _stellarXdr_generated = require('./generated/stellar-xdr_generated');\n\nvar _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);\n\nvar _keypair = require('./keypair');\n\nvar _transaction = require('./transaction');\n\nvar _memo = require('./memo');\n\nvar _network = require('./network');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Minimum base fee for transactions. If this fee is below the network\n * minimum, the transaction will fail. The more operations in the\n * transaction, the greater the required fee. Use {@link\n * Server#fetchBaseFee} to get an accurate value of minimum transaction\n * fee on the network.\n *\n * @constant\n * @see [Fees](https://www.stellar.org/developers/guides/concepts/fees.html)\n */\n\n\nvar BASE_FEE = exports.BASE_FEE = 100; // Stroops\n\n/**\n * @constant\n * @see {@link TransactionBuilder#setTimeout}\n * @see [Timeout](https://www.stellar.org/developers/horizon/reference/endpoints/transactions-create.html#timeout)\n */\n\nvar TimeoutInfinite = exports.TimeoutInfinite = 0;\n/**\n * <p>Transaction builder helps constructs a new `{@link Transaction}` using the given {@link Account}\n * as the transaction's \"source account\". The transaction will use the current sequence\n * number of the given account as its sequence number and increment the given account's\n * sequence number by one. The given source account must include a private key for signing\n * the transaction or an error will be thrown.</p>\n *\n * <p>Operations can be added to the transaction via their corresponding builder methods, and\n * each returns the TransactionBuilder object so they can be chained together. After adding\n * the desired operations, call the `build()` method on the `TransactionBuilder` to return a fully\n * constructed `{@link Transaction}` that can be signed. The returned transaction will contain the\n * sequence number of the source account and include the signature from the source account.</p>\n *\n * <p><strong>Be careful about unsubmitted transactions!</strong> When you build a transaction, stellar-sdk\n * automatically increments the source account's sequence number. If you end up\n * not submitting this transaction and submitting another one instead, it'll fail due to\n * the sequence number being wrong. So if you decide not to use a built transaction,\n * make sure to update the source account's sequence number\n * with [Server.loadAccount](https://stellar.github.io/js-stellar-sdk/Server.html#loadAccount) before creating another transaction.</p>\n *\n * <p>The following code example creates a new transaction with {@link Operation.createAccount} and\n * {@link Operation.payment} operations.\n * The Transaction's source account first funds `destinationA`, then sends\n * a payment to `destinationB`. The built transaction is then signed by `sourceKeypair`.</p>\n *\n * ```\n * var transaction = new TransactionBuilder(source, { fee, networkPassphrase: Networks.TESTNET })\n * .addOperation(Operation.createAccount({\n *     destination: destinationA,\n *     startingBalance: \"20\"\n * })) // <- funds and creates destinationA\n * .addOperation(Operation.payment({\n *     destination: destinationB,\n *     amount: \"100\",\n *     asset: Asset.native()\n * })) // <- sends 100 XLM to destinationB\n * .setTimeout(30)\n * .build();\n *\n * transaction.sign(sourceKeypair);\n * ```\n * @constructor\n * @param {Account} sourceAccount - The source account for this transaction.\n * @param {object} opts Options object\n * @param {number} opts.fee - The max fee willing to pay per operation in this transaction (**in stroops**). Required.\n * @param {object} [opts.timebounds] - The timebounds for the validity of this transaction.\n * @param {number|string|Date} [opts.timebounds.minTime] - 64 bit unix timestamp or Date object\n * @param {number|string|Date} [opts.timebounds.maxTime] - 64 bit unix timestamp or Date object\n * @param {Memo} [opts.memo] - The memo for the transaction\n * @param {string} [opts.networkPassphrase] passphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n */\n\nvar TransactionBuilder = exports.TransactionBuilder = function () {\n  function TransactionBuilder(sourceAccount) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TransactionBuilder);\n\n    if (!sourceAccount) {\n      throw new Error('must specify source account for the transaction');\n    }\n\n    if ((0, _isUndefined2.default)(opts.fee)) {\n      throw new Error('must specify fee for the transaction (in stroops)');\n    }\n\n    this.source = sourceAccount;\n    this.operations = [];\n    this.baseFee = (0, _isUndefined2.default)(opts.fee) ? BASE_FEE : opts.fee;\n    this.timebounds = (0, _clone2.default)(opts.timebounds) || null;\n    this.memo = opts.memo || _memo.Memo.none();\n    this.timeoutSet = false;\n    this.networkPassphrase = opts.networkPassphrase || null;\n  }\n  /**\n   * Adds an operation to the transaction.\n   * @param {xdr.Operation} operation The xdr operation object, use {@link Operation} static methods.\n   * @returns {TransactionBuilder}\n   */\n\n\n  _createClass(TransactionBuilder, [{\n    key: 'addOperation',\n    value: function addOperation(operation) {\n      this.operations.push(operation);\n      return this;\n    }\n    /**\n     * Adds a memo to the transaction.\n     * @param {Memo} memo {@link Memo} object\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'addMemo',\n    value: function addMemo(memo) {\n      this.memo = memo;\n      return this;\n    }\n    /**\n     * Because of the distributed nature of the Stellar network it is possible that the status of your transaction\n     * will be determined after a long time if the network is highly congested.\n     * If you want to be sure to receive the status of the transaction within a given period you should set the\n     * {@link TimeBounds} with <code>maxTime</code> on the transaction (this is what <code>setTimeout</code> does\n     * internally; if there's <code>minTime</code> set but no <code>maxTime</code> it will be added).\n     * Call to <code>TransactionBuilder.setTimeout</code> is required if Transaction does not have <code>max_time</code> set.\n     * If you don't want to set timeout, use <code>{@link TimeoutInfinite}</code>. In general you should set\n     * <code>{@link TimeoutInfinite}</code> only in smart contracts.\n     *\n     * Please note that Horizon may still return <code>504 Gateway Timeout</code> error, even for short timeouts.\n     * In such case you need to resubmit the same transaction again without making any changes to receive a status.\n     * This method is using the machine system time (UTC), make sure it is set correctly.\n     * @param {number} timeout Number of seconds the transaction is good. Can't be negative.\n     * If the value is `0`, the transaction is good indefinitely.\n     * @return {TransactionBuilder}\n     * @see TimeoutInfinite\n     */\n\n  }, {\n    key: 'setTimeout',\n    value: function setTimeout(timeout) {\n      if (this.timebounds != null && this.timebounds.maxTime > 0) {\n        throw new Error('TimeBounds.max_time has been already set - setting timeout would overwrite it.');\n      }\n\n      if (timeout < 0) {\n        throw new Error('timeout cannot be negative');\n      }\n\n      this.timeoutSet = true;\n\n      if (timeout > 0) {\n        var timeoutTimestamp = Math.floor(Date.now() / 1000) + timeout;\n\n        if (this.timebounds === null) {\n          this.timebounds = {\n            minTime: 0,\n            maxTime: timeoutTimestamp\n          };\n        } else {\n          this.timebounds = {\n            minTime: this.timebounds.minTime,\n            maxTime: timeoutTimestamp\n          };\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Set network nassphrase for the Transaction that will be built.\n     *\n     * @param {string} [networkPassphrase] passphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setNetworkPassphrase',\n    value: function setNetworkPassphrase(networkPassphrase) {\n      this.networkPassphrase = networkPassphrase;\n      return this;\n    }\n    /**\n     * This will build the transaction.\n     * It will also increment the source account's sequence number by 1.\n     * @returns {Transaction} This method will return the built {@link Transaction}.\n     */\n\n  }, {\n    key: 'build',\n    value: function build() {\n      // Ensure setTimeout called or maxTime is set\n      if ((this.timebounds === null || this.timebounds !== null && this.timebounds.maxTime === 0) && !this.timeoutSet) {\n        throw new Error('TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).');\n      }\n\n      var sequenceNumber = new _bignumber2.default(this.source.sequenceNumber()).add(1);\n      var attrs = {\n        sourceAccount: _keypair.Keypair.fromPublicKey(this.source.accountId()).xdrAccountId(),\n        fee: this.baseFee * this.operations.length,\n        seqNum: _stellarXdr_generated2.default.SequenceNumber.fromString(sequenceNumber.toString()),\n        memo: this.memo ? this.memo.toXDRObject() : null,\n        ext: new _stellarXdr_generated2.default.TransactionExt(0)\n      };\n\n      if (this.timebounds) {\n        if (isValidDate(this.timebounds.minTime)) {\n          this.timebounds.minTime = this.timebounds.minTime.getTime() / 1000;\n        }\n\n        if (isValidDate(this.timebounds.maxTime)) {\n          this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1000;\n        }\n\n        this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());\n        this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());\n        attrs.timeBounds = new _stellarXdr_generated2.default.TimeBounds(this.timebounds);\n      }\n\n      var xtx = new _stellarXdr_generated2.default.Transaction(attrs);\n      xtx.operations(this.operations);\n      var xenv = new _stellarXdr_generated2.default.TransactionEnvelope({\n        tx: xtx\n      });\n      var tx = new _transaction.Transaction(xenv, this.networkPassphrase);\n      this.source.incrementSequenceNumber();\n      return tx;\n    }\n  }]);\n\n  return TransactionBuilder;\n}();\n/**\n * Checks whether a provided object is a valid Date.\n * @argument {Date} d date object\n * @returns {boolean}\n */\n\n\nfunction isValidDate(d) {\n  // isnan is okay here because it correctly checks for invalid date objects\n  // eslint-disable-next-line no-restricted-globals\n  return d instanceof Date && !isNaN(d);\n}","map":{"version":3,"sources":["/home/azureuser/foregin-transfers-with-stellar/infrastructure/pageB/node_modules/stellar-base/lib/transaction_builder.js"],"names":["Object","defineProperty","exports","value","TransactionBuilder","TimeoutInfinite","BASE_FEE","undefined","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","isValidDate","_jsXdr","require","_bignumber","_bignumber2","_interopRequireDefault","_clone","_clone2","_isUndefined","_isUndefined2","_stellarXdr_generated","_stellarXdr_generated2","_keypair","_transaction","_memo","_network","obj","__esModule","default","_classCallCheck","instance","TypeError","sourceAccount","opts","arguments","Error","fee","source","operations","baseFee","timebounds","memo","Memo","none","timeoutSet","networkPassphrase","addOperation","operation","push","addMemo","setTimeout","timeout","maxTime","timeoutTimestamp","Math","floor","Date","now","minTime","setNetworkPassphrase","build","sequenceNumber","add","attrs","Keypair","fromPublicKey","accountId","xdrAccountId","seqNum","SequenceNumber","fromString","toString","toXDRObject","ext","TransactionExt","getTime","UnsignedHyper","timeBounds","TimeBounds","xtx","Transaction","xenv","TransactionEnvelope","tx","incrementSequenceNumber","d","isNaN"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isValidDate = isValidDate;\n\nvar _jsXdr = require('js-xdr');\n\nvar _bignumber = require('bignumber.js');\n\nvar _bignumber2 = _interopRequireDefault(_bignumber);\n\nvar _clone = require('lodash/clone');\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _isUndefined = require('lodash/isUndefined');\n\nvar _isUndefined2 = _interopRequireDefault(_isUndefined);\n\nvar _stellarXdr_generated = require('./generated/stellar-xdr_generated');\n\nvar _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);\n\nvar _keypair = require('./keypair');\n\nvar _transaction = require('./transaction');\n\nvar _memo = require('./memo');\n\nvar _network = require('./network');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Minimum base fee for transactions. If this fee is below the network\n * minimum, the transaction will fail. The more operations in the\n * transaction, the greater the required fee. Use {@link\n * Server#fetchBaseFee} to get an accurate value of minimum transaction\n * fee on the network.\n *\n * @constant\n * @see [Fees](https://www.stellar.org/developers/guides/concepts/fees.html)\n */\nvar BASE_FEE = exports.BASE_FEE = 100; // Stroops\n\n/**\n * @constant\n * @see {@link TransactionBuilder#setTimeout}\n * @see [Timeout](https://www.stellar.org/developers/horizon/reference/endpoints/transactions-create.html#timeout)\n */\nvar TimeoutInfinite = exports.TimeoutInfinite = 0;\n\n/**\n * <p>Transaction builder helps constructs a new `{@link Transaction}` using the given {@link Account}\n * as the transaction's \"source account\". The transaction will use the current sequence\n * number of the given account as its sequence number and increment the given account's\n * sequence number by one. The given source account must include a private key for signing\n * the transaction or an error will be thrown.</p>\n *\n * <p>Operations can be added to the transaction via their corresponding builder methods, and\n * each returns the TransactionBuilder object so they can be chained together. After adding\n * the desired operations, call the `build()` method on the `TransactionBuilder` to return a fully\n * constructed `{@link Transaction}` that can be signed. The returned transaction will contain the\n * sequence number of the source account and include the signature from the source account.</p>\n *\n * <p><strong>Be careful about unsubmitted transactions!</strong> When you build a transaction, stellar-sdk\n * automatically increments the source account's sequence number. If you end up\n * not submitting this transaction and submitting another one instead, it'll fail due to\n * the sequence number being wrong. So if you decide not to use a built transaction,\n * make sure to update the source account's sequence number\n * with [Server.loadAccount](https://stellar.github.io/js-stellar-sdk/Server.html#loadAccount) before creating another transaction.</p>\n *\n * <p>The following code example creates a new transaction with {@link Operation.createAccount} and\n * {@link Operation.payment} operations.\n * The Transaction's source account first funds `destinationA`, then sends\n * a payment to `destinationB`. The built transaction is then signed by `sourceKeypair`.</p>\n *\n * ```\n * var transaction = new TransactionBuilder(source, { fee, networkPassphrase: Networks.TESTNET })\n * .addOperation(Operation.createAccount({\n *     destination: destinationA,\n *     startingBalance: \"20\"\n * })) // <- funds and creates destinationA\n * .addOperation(Operation.payment({\n *     destination: destinationB,\n *     amount: \"100\",\n *     asset: Asset.native()\n * })) // <- sends 100 XLM to destinationB\n * .setTimeout(30)\n * .build();\n *\n * transaction.sign(sourceKeypair);\n * ```\n * @constructor\n * @param {Account} sourceAccount - The source account for this transaction.\n * @param {object} opts Options object\n * @param {number} opts.fee - The max fee willing to pay per operation in this transaction (**in stroops**). Required.\n * @param {object} [opts.timebounds] - The timebounds for the validity of this transaction.\n * @param {number|string|Date} [opts.timebounds.minTime] - 64 bit unix timestamp or Date object\n * @param {number|string|Date} [opts.timebounds.maxTime] - 64 bit unix timestamp or Date object\n * @param {Memo} [opts.memo] - The memo for the transaction\n * @param {string} [opts.networkPassphrase] passphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n */\n\nvar TransactionBuilder = exports.TransactionBuilder = function () {\n  function TransactionBuilder(sourceAccount) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TransactionBuilder);\n\n    if (!sourceAccount) {\n      throw new Error('must specify source account for the transaction');\n    }\n\n    if ((0, _isUndefined2.default)(opts.fee)) {\n      throw new Error('must specify fee for the transaction (in stroops)');\n    }\n\n    this.source = sourceAccount;\n    this.operations = [];\n\n    this.baseFee = (0, _isUndefined2.default)(opts.fee) ? BASE_FEE : opts.fee;\n    this.timebounds = (0, _clone2.default)(opts.timebounds) || null;\n    this.memo = opts.memo || _memo.Memo.none();\n    this.timeoutSet = false;\n    this.networkPassphrase = opts.networkPassphrase || null;\n  }\n\n  /**\n   * Adds an operation to the transaction.\n   * @param {xdr.Operation} operation The xdr operation object, use {@link Operation} static methods.\n   * @returns {TransactionBuilder}\n   */\n\n\n  _createClass(TransactionBuilder, [{\n    key: 'addOperation',\n    value: function addOperation(operation) {\n      this.operations.push(operation);\n      return this;\n    }\n\n    /**\n     * Adds a memo to the transaction.\n     * @param {Memo} memo {@link Memo} object\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'addMemo',\n    value: function addMemo(memo) {\n      this.memo = memo;\n      return this;\n    }\n\n    /**\n     * Because of the distributed nature of the Stellar network it is possible that the status of your transaction\n     * will be determined after a long time if the network is highly congested.\n     * If you want to be sure to receive the status of the transaction within a given period you should set the\n     * {@link TimeBounds} with <code>maxTime</code> on the transaction (this is what <code>setTimeout</code> does\n     * internally; if there's <code>minTime</code> set but no <code>maxTime</code> it will be added).\n     * Call to <code>TransactionBuilder.setTimeout</code> is required if Transaction does not have <code>max_time</code> set.\n     * If you don't want to set timeout, use <code>{@link TimeoutInfinite}</code>. In general you should set\n     * <code>{@link TimeoutInfinite}</code> only in smart contracts.\n     *\n     * Please note that Horizon may still return <code>504 Gateway Timeout</code> error, even for short timeouts.\n     * In such case you need to resubmit the same transaction again without making any changes to receive a status.\n     * This method is using the machine system time (UTC), make sure it is set correctly.\n     * @param {number} timeout Number of seconds the transaction is good. Can't be negative.\n     * If the value is `0`, the transaction is good indefinitely.\n     * @return {TransactionBuilder}\n     * @see TimeoutInfinite\n     */\n\n  }, {\n    key: 'setTimeout',\n    value: function setTimeout(timeout) {\n      if (this.timebounds != null && this.timebounds.maxTime > 0) {\n        throw new Error('TimeBounds.max_time has been already set - setting timeout would overwrite it.');\n      }\n\n      if (timeout < 0) {\n        throw new Error('timeout cannot be negative');\n      }\n\n      this.timeoutSet = true;\n      if (timeout > 0) {\n        var timeoutTimestamp = Math.floor(Date.now() / 1000) + timeout;\n        if (this.timebounds === null) {\n          this.timebounds = { minTime: 0, maxTime: timeoutTimestamp };\n        } else {\n          this.timebounds = {\n            minTime: this.timebounds.minTime,\n            maxTime: timeoutTimestamp\n          };\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * Set network nassphrase for the Transaction that will be built.\n     *\n     * @param {string} [networkPassphrase] passphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setNetworkPassphrase',\n    value: function setNetworkPassphrase(networkPassphrase) {\n      this.networkPassphrase = networkPassphrase;\n      return this;\n    }\n\n    /**\n     * This will build the transaction.\n     * It will also increment the source account's sequence number by 1.\n     * @returns {Transaction} This method will return the built {@link Transaction}.\n     */\n\n  }, {\n    key: 'build',\n    value: function build() {\n      // Ensure setTimeout called or maxTime is set\n      if ((this.timebounds === null || this.timebounds !== null && this.timebounds.maxTime === 0) && !this.timeoutSet) {\n        throw new Error('TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).');\n      }\n\n      var sequenceNumber = new _bignumber2.default(this.source.sequenceNumber()).add(1);\n\n      var attrs = {\n        sourceAccount: _keypair.Keypair.fromPublicKey(this.source.accountId()).xdrAccountId(),\n        fee: this.baseFee * this.operations.length,\n        seqNum: _stellarXdr_generated2.default.SequenceNumber.fromString(sequenceNumber.toString()),\n        memo: this.memo ? this.memo.toXDRObject() : null,\n        ext: new _stellarXdr_generated2.default.TransactionExt(0)\n      };\n\n      if (this.timebounds) {\n        if (isValidDate(this.timebounds.minTime)) {\n          this.timebounds.minTime = this.timebounds.minTime.getTime() / 1000;\n        }\n        if (isValidDate(this.timebounds.maxTime)) {\n          this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1000;\n        }\n\n        this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());\n        this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());\n\n        attrs.timeBounds = new _stellarXdr_generated2.default.TimeBounds(this.timebounds);\n      }\n\n      var xtx = new _stellarXdr_generated2.default.Transaction(attrs);\n      xtx.operations(this.operations);\n\n      var xenv = new _stellarXdr_generated2.default.TransactionEnvelope({ tx: xtx });\n      var tx = new _transaction.Transaction(xenv, this.networkPassphrase);\n\n      this.source.incrementSequenceNumber();\n\n      return tx;\n    }\n  }]);\n\n  return TransactionBuilder;\n}();\n\n/**\n * Checks whether a provided object is a valid Date.\n * @argument {Date} d date object\n * @returns {boolean}\n */\n\n\nfunction isValidDate(d) {\n  // isnan is okay here because it correctly checks for invalid date objects\n  // eslint-disable-next-line no-restricted-globals\n  return d instanceof Date && !isNaN(d);\n}"]},"metadata":{},"sourceType":"script"}