{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jsXdr = require(\"js-xdr\");\n\nvar XDR = _interopRequireWildcard(_jsXdr);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar types = XDR.config(function (xdr) {\n  // === xdr source ============================================================\n  //\n  //   typedef PublicKey AccountID;\n  //\n  // ===========================================================================\n  xdr.typedef(\"AccountId\", xdr.lookup(\"PublicKey\")); // === xdr source ============================================================\n  //\n  //   typedef opaque Thresholds[4];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Thresholds\", xdr.opaque(4)); // === xdr source ============================================================\n  //\n  //   typedef string string32<32>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"String32\", xdr.string(32)); // === xdr source ============================================================\n  //\n  //   typedef string string64<64>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"String64\", xdr.string(64)); // === xdr source ============================================================\n  //\n  //   typedef int64 SequenceNumber;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"SequenceNumber\", xdr.lookup(\"Int64\")); // === xdr source ============================================================\n  //\n  //   typedef uint64 TimePoint;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"TimePoint\", xdr.lookup(\"Uint64\")); // === xdr source ============================================================\n  //\n  //   typedef opaque DataValue<64>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"DataValue\", xdr.varOpaque(64)); // === xdr source ============================================================\n  //\n  //   typedef opaque AssetCode4[4];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"AssetCode4\", xdr.opaque(4)); // === xdr source ============================================================\n  //\n  //   typedef opaque AssetCode12[12];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"AssetCode12\", xdr.opaque(12)); // === xdr source ============================================================\n  //\n  //   enum AssetType\n  //   {\n  //       ASSET_TYPE_NATIVE = 0,\n  //       ASSET_TYPE_CREDIT_ALPHANUM4 = 1,\n  //       ASSET_TYPE_CREDIT_ALPHANUM12 = 2\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"AssetType\", {\n    assetTypeNative: 0,\n    assetTypeCreditAlphanum4: 1,\n    assetTypeCreditAlphanum12: 2\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AssetCode4 assetCode;\n  //           AccountID issuer;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AssetAlphaNum4\", [[\"assetCode\", xdr.lookup(\"AssetCode4\")], [\"issuer\", xdr.lookup(\"AccountId\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AssetCode12 assetCode;\n  //           AccountID issuer;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AssetAlphaNum12\", [[\"assetCode\", xdr.lookup(\"AssetCode12\")], [\"issuer\", xdr.lookup(\"AccountId\")]]); // === xdr source ============================================================\n  //\n  //   union Asset switch (AssetType type)\n  //   {\n  //   case ASSET_TYPE_NATIVE: // Not credit\n  //       void;\n  //   \n  //   case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //       struct\n  //       {\n  //           AssetCode4 assetCode;\n  //           AccountID issuer;\n  //       } alphaNum4;\n  //   \n  //   case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //       struct\n  //       {\n  //           AssetCode12 assetCode;\n  //           AccountID issuer;\n  //       } alphaNum12;\n  //   \n  //       // add other asset types here in the future\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"Asset\", {\n    switchOn: xdr.lookup(\"AssetType\"),\n    switchName: \"type\",\n    switches: [[\"assetTypeNative\", xdr.void()], [\"assetTypeCreditAlphanum4\", \"alphaNum4\"], [\"assetTypeCreditAlphanum12\", \"alphaNum12\"]],\n    arms: {\n      alphaNum4: xdr.lookup(\"AssetAlphaNum4\"),\n      alphaNum12: xdr.lookup(\"AssetAlphaNum12\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct Price\n  //   {\n  //       int32 n; // numerator\n  //       int32 d; // denominator\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Price\", [[\"n\", xdr.lookup(\"Int32\")], [\"d\", xdr.lookup(\"Int32\")]]); // === xdr source ============================================================\n  //\n  //   struct Liabilities\n  //   {\n  //       int64 buying;\n  //       int64 selling;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Liabilities\", [[\"buying\", xdr.lookup(\"Int64\")], [\"selling\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   enum ThresholdIndexes\n  //   {\n  //       THRESHOLD_MASTER_WEIGHT = 0,\n  //       THRESHOLD_LOW = 1,\n  //       THRESHOLD_MED = 2,\n  //       THRESHOLD_HIGH = 3\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ThresholdIndices\", {\n    thresholdMasterWeight: 0,\n    thresholdLow: 1,\n    thresholdMed: 2,\n    thresholdHigh: 3\n  }); // === xdr source ============================================================\n  //\n  //   enum LedgerEntryType\n  //   {\n  //       ACCOUNT = 0,\n  //       TRUSTLINE = 1,\n  //       OFFER = 2,\n  //       DATA = 3\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"LedgerEntryType\", {\n    account: 0,\n    trustline: 1,\n    offer: 2,\n    datum: 3\n  }); // === xdr source ============================================================\n  //\n  //   struct Signer\n  //   {\n  //       SignerKey key;\n  //       uint32 weight; // really only need 1 byte\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Signer\", [[\"key\", xdr.lookup(\"SignerKey\")], [\"weight\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   enum AccountFlags\n  //   { // masks for each flag\n  //   \n  //       // Flags set on issuer accounts\n  //       // TrustLines are created with authorized set to \"false\" requiring\n  //       // the issuer to set it for each TrustLine\n  //       AUTH_REQUIRED_FLAG = 0x1,\n  //       // If set, the authorized flag in TrustLines can be cleared\n  //       // otherwise, authorization cannot be revoked\n  //       AUTH_REVOCABLE_FLAG = 0x2,\n  //       // Once set, causes all AUTH_* flags to be read-only\n  //       AUTH_IMMUTABLE_FLAG = 0x4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"AccountFlags\", {\n    authRequiredFlag: 1,\n    authRevocableFlag: 2,\n    authImmutableFlag: 4\n  }); // === xdr source ============================================================\n  //\n  //   const MASK_ACCOUNT_FLAGS = 0x7;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MASK_ACCOUNT_FLAGS\", 0x7); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //\n  // ===========================================================================\n\n  xdr.union(\"AccountEntryV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AccountEntryV1\", [[\"liabilities\", xdr.lookup(\"Liabilities\")], [\"ext\", xdr.lookup(\"AccountEntryV1Ext\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"AccountEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"AccountEntryV1\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct AccountEntry\n  //   {\n  //       AccountID accountID;      // master public key for this account\n  //       int64 balance;            // in stroops\n  //       SequenceNumber seqNum;    // last sequence number used for this account\n  //       uint32 numSubEntries;     // number of sub-entries this account has\n  //                                 // drives the reserve\n  //       AccountID* inflationDest; // Account to vote for during inflation\n  //       uint32 flags;             // see AccountFlags\n  //   \n  //       string32 homeDomain; // can be used for reverse federation and memo lookup\n  //   \n  //       // fields used for signatures\n  //       // thresholds stores unsigned bytes: [weight of master|low|medium|high]\n  //       Thresholds thresholds;\n  //   \n  //       Signer signers<20>; // possible signers for this account\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AccountEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"balance\", xdr.lookup(\"Int64\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"numSubEntries\", xdr.lookup(\"Uint32\")], [\"inflationDest\", xdr.option(xdr.lookup(\"AccountId\"))], [\"flags\", xdr.lookup(\"Uint32\")], [\"homeDomain\", xdr.lookup(\"String32\")], [\"thresholds\", xdr.lookup(\"Thresholds\")], [\"signers\", xdr.varArray(xdr.lookup(\"Signer\"), 20)], [\"ext\", xdr.lookup(\"AccountEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   enum TrustLineFlags\n  //   {\n  //       // issuer has authorized account to perform transactions with its credit\n  //       AUTHORIZED_FLAG = 1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"TrustLineFlags\", {\n    authorizedFlag: 1\n  }); // === xdr source ============================================================\n  //\n  //   const MASK_TRUSTLINE_FLAGS = 1;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MASK_TRUSTLINE_FLAGS\", 1); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TrustLineEntryV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TrustLineEntryV1\", [[\"liabilities\", xdr.lookup(\"Liabilities\")], [\"ext\", xdr.lookup(\"TrustLineEntryV1Ext\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TrustLineEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"TrustLineEntryV1\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TrustLineEntry\n  //   {\n  //       AccountID accountID; // account this trustline belongs to\n  //       Asset asset;         // type of asset (with issuer)\n  //       int64 balance;       // how much of this asset the user has.\n  //                            // Asset defines the unit for this;\n  //   \n  //       int64 limit;  // balance cannot be above this\n  //       uint32 flags; // see TrustLineFlags\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TrustLineEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"balance\", xdr.lookup(\"Int64\")], [\"limit\", xdr.lookup(\"Int64\")], [\"flags\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"TrustLineEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   enum OfferEntryFlags\n  //   {\n  //       // issuer has authorized account to perform transactions with its credit\n  //       PASSIVE_FLAG = 1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"OfferEntryFlags\", {\n    passiveFlag: 1\n  }); // === xdr source ============================================================\n  //\n  //   const MASK_OFFERENTRY_FLAGS = 1;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MASK_OFFERENTRY_FLAGS\", 1); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"OfferEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct OfferEntry\n  //   {\n  //       AccountID sellerID;\n  //       int64 offerID;\n  //       Asset selling; // A\n  //       Asset buying;  // B\n  //       int64 amount;  // amount of A\n  //   \n  //       /* price for this offer:\n  //           price of A in terms of B\n  //           price=AmountB/AmountA=priceNumerator/priceDenominator\n  //           price is after fees\n  //       */\n  //       Price price;\n  //       uint32 flags; // see OfferEntryFlags\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"OfferEntry\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")], [\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"flags\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"OfferEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"DataEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct DataEntry\n  //   {\n  //       AccountID accountID; // account this data belongs to\n  //       string64 dataName;\n  //       DataValue dataValue;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"DataEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"dataName\", xdr.lookup(\"String64\")], [\"dataValue\", xdr.lookup(\"DataValue\")], [\"ext\", xdr.lookup(\"DataEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (LedgerEntryType type)\n  //       {\n  //       case ACCOUNT:\n  //           AccountEntry account;\n  //       case TRUSTLINE:\n  //           TrustLineEntry trustLine;\n  //       case OFFER:\n  //           OfferEntry offer;\n  //       case DATA:\n  //           DataEntry data;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerEntryData\", {\n    switchOn: xdr.lookup(\"LedgerEntryType\"),\n    switchName: \"type\",\n    switches: [[\"account\", \"account\"], [\"trustline\", \"trustLine\"], [\"offer\", \"offer\"], [\"datum\", \"data\"]],\n    arms: {\n      account: xdr.lookup(\"AccountEntry\"),\n      trustLine: xdr.lookup(\"TrustLineEntry\"),\n      offer: xdr.lookup(\"OfferEntry\"),\n      data: xdr.lookup(\"DataEntry\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerEntry\n  //   {\n  //       uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed\n  //   \n  //       union switch (LedgerEntryType type)\n  //       {\n  //       case ACCOUNT:\n  //           AccountEntry account;\n  //       case TRUSTLINE:\n  //           TrustLineEntry trustLine;\n  //       case OFFER:\n  //           OfferEntry offer;\n  //       case DATA:\n  //           DataEntry data;\n  //       }\n  //       data;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerEntry\", [[\"lastModifiedLedgerSeq\", xdr.lookup(\"Uint32\")], [\"data\", xdr.lookup(\"LedgerEntryData\")], [\"ext\", xdr.lookup(\"LedgerEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   enum EnvelopeType\n  //   {\n  //       ENVELOPE_TYPE_SCP = 1,\n  //       ENVELOPE_TYPE_TX = 2,\n  //       ENVELOPE_TYPE_AUTH = 3,\n  //       ENVELOPE_TYPE_SCPVALUE = 4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"EnvelopeType\", {\n    envelopeTypeScp: 1,\n    envelopeTypeTx: 2,\n    envelopeTypeAuth: 3,\n    envelopeTypeScpvalue: 4\n  }); // === xdr source ============================================================\n  //\n  //   typedef opaque UpgradeType<128>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"UpgradeType\", xdr.varOpaque(128)); // === xdr source ============================================================\n  //\n  //   enum StellarValueType\n  //   {\n  //       STELLAR_VALUE_BASIC = 0,\n  //       STELLAR_VALUE_SIGNED = 1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"StellarValueType\", {\n    stellarValueBasic: 0,\n    stellarValueSigned: 1\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerCloseValueSignature\n  //   {\n  //       NodeID nodeID;       // which node introduced the value\n  //       Signature signature; // nodeID's signature\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerCloseValueSignature\", [[\"nodeId\", xdr.lookup(\"NodeId\")], [\"signature\", xdr.lookup(\"Signature\")]]); // === xdr source ============================================================\n  //\n  //   union switch (StellarValueType v)\n  //       {\n  //       case STELLAR_VALUE_BASIC:\n  //           void;\n  //       case STELLAR_VALUE_SIGNED:\n  //           LedgerCloseValueSignature lcValueSignature;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"StellarValueExt\", {\n    switchOn: xdr.lookup(\"StellarValueType\"),\n    switchName: \"v\",\n    switches: [[\"stellarValueBasic\", xdr.void()], [\"stellarValueSigned\", \"lcValueSignature\"]],\n    arms: {\n      lcValueSignature: xdr.lookup(\"LedgerCloseValueSignature\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct StellarValue\n  //   {\n  //       Hash txSetHash;      // transaction set to apply to previous ledger\n  //       TimePoint closeTime; // network close time\n  //   \n  //       // upgrades to apply to the previous ledger (usually empty)\n  //       // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop\n  //       // unknown steps during consensus if needed.\n  //       // see notes below on 'LedgerUpgrade' for more detail\n  //       // max size is dictated by number of upgrade types (+ room for future)\n  //       UpgradeType upgrades<6>;\n  //   \n  //       // reserved for future use\n  //       union switch (StellarValueType v)\n  //       {\n  //       case STELLAR_VALUE_BASIC:\n  //           void;\n  //       case STELLAR_VALUE_SIGNED:\n  //           LedgerCloseValueSignature lcValueSignature;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"StellarValue\", [[\"txSetHash\", xdr.lookup(\"Hash\")], [\"closeTime\", xdr.lookup(\"TimePoint\")], [\"upgrades\", xdr.varArray(xdr.lookup(\"UpgradeType\"), 6)], [\"ext\", xdr.lookup(\"StellarValueExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerHeaderExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerHeader\n  //   {\n  //       uint32 ledgerVersion;    // the protocol version of the ledger\n  //       Hash previousLedgerHash; // hash of the previous ledger header\n  //       StellarValue scpValue;   // what consensus agreed to\n  //       Hash txSetResultHash;    // the TransactionResultSet that led to this ledger\n  //       Hash bucketListHash;     // hash of the ledger state\n  //   \n  //       uint32 ledgerSeq; // sequence number of this ledger\n  //   \n  //       int64 totalCoins; // total number of stroops in existence.\n  //                         // 10,000,000 stroops in 1 XLM\n  //   \n  //       int64 feePool;       // fees burned since last inflation run\n  //       uint32 inflationSeq; // inflation sequence number\n  //   \n  //       uint64 idPool; // last used global ID, used for generating objects\n  //   \n  //       uint32 baseFee;     // base fee per operation in stroops\n  //       uint32 baseReserve; // account base reserve in stroops\n  //   \n  //       uint32 maxTxSetSize; // maximum size a transaction set can be\n  //   \n  //       Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back\n  //                         // in time without walking the chain back ledger by ledger\n  //                         // each slot contains the oldest ledger that is mod of\n  //                         // either 50  5000  50000 or 500000 depending on index\n  //                         // skipList[0] mod(50), skipList[1] mod(5000), etc\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerHeader\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"previousLedgerHash\", xdr.lookup(\"Hash\")], [\"scpValue\", xdr.lookup(\"StellarValue\")], [\"txSetResultHash\", xdr.lookup(\"Hash\")], [\"bucketListHash\", xdr.lookup(\"Hash\")], [\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"totalCoins\", xdr.lookup(\"Int64\")], [\"feePool\", xdr.lookup(\"Int64\")], [\"inflationSeq\", xdr.lookup(\"Uint32\")], [\"idPool\", xdr.lookup(\"Uint64\")], [\"baseFee\", xdr.lookup(\"Uint32\")], [\"baseReserve\", xdr.lookup(\"Uint32\")], [\"maxTxSetSize\", xdr.lookup(\"Uint32\")], [\"skipList\", xdr.array(xdr.lookup(\"Hash\"), 4)], [\"ext\", xdr.lookup(\"LedgerHeaderExt\")]]); // === xdr source ============================================================\n  //\n  //   enum LedgerUpgradeType\n  //   {\n  //       LEDGER_UPGRADE_VERSION = 1,\n  //       LEDGER_UPGRADE_BASE_FEE = 2,\n  //       LEDGER_UPGRADE_MAX_TX_SET_SIZE = 3,\n  //       LEDGER_UPGRADE_BASE_RESERVE = 4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"LedgerUpgradeType\", {\n    ledgerUpgradeVersion: 1,\n    ledgerUpgradeBaseFee: 2,\n    ledgerUpgradeMaxTxSetSize: 3,\n    ledgerUpgradeBaseReserve: 4\n  }); // === xdr source ============================================================\n  //\n  //   union LedgerUpgrade switch (LedgerUpgradeType type)\n  //   {\n  //   case LEDGER_UPGRADE_VERSION:\n  //       uint32 newLedgerVersion; // update ledgerVersion\n  //   case LEDGER_UPGRADE_BASE_FEE:\n  //       uint32 newBaseFee; // update baseFee\n  //   case LEDGER_UPGRADE_MAX_TX_SET_SIZE:\n  //       uint32 newMaxTxSetSize; // update maxTxSetSize\n  //   case LEDGER_UPGRADE_BASE_RESERVE:\n  //       uint32 newBaseReserve; // update baseReserve\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerUpgrade\", {\n    switchOn: xdr.lookup(\"LedgerUpgradeType\"),\n    switchName: \"type\",\n    switches: [[\"ledgerUpgradeVersion\", \"newLedgerVersion\"], [\"ledgerUpgradeBaseFee\", \"newBaseFee\"], [\"ledgerUpgradeMaxTxSetSize\", \"newMaxTxSetSize\"], [\"ledgerUpgradeBaseReserve\", \"newBaseReserve\"]],\n    arms: {\n      newLedgerVersion: xdr.lookup(\"Uint32\"),\n      newBaseFee: xdr.lookup(\"Uint32\"),\n      newMaxTxSetSize: xdr.lookup(\"Uint32\"),\n      newBaseReserve: xdr.lookup(\"Uint32\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyAccount\", [[\"accountId\", xdr.lookup(\"AccountId\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           Asset asset;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyTrustLine\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID sellerID;\n  //           int64 offerID;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyOffer\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           string64 dataName;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyData\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"dataName\", xdr.lookup(\"String64\")]]); // === xdr source ============================================================\n  //\n  //   union LedgerKey switch (LedgerEntryType type)\n  //   {\n  //   case ACCOUNT:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //       } account;\n  //   \n  //   case TRUSTLINE:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           Asset asset;\n  //       } trustLine;\n  //   \n  //   case OFFER:\n  //       struct\n  //       {\n  //           AccountID sellerID;\n  //           int64 offerID;\n  //       } offer;\n  //   \n  //   case DATA:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           string64 dataName;\n  //       } data;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerKey\", {\n    switchOn: xdr.lookup(\"LedgerEntryType\"),\n    switchName: \"type\",\n    switches: [[\"account\", \"account\"], [\"trustline\", \"trustLine\"], [\"offer\", \"offer\"], [\"datum\", \"data\"]],\n    arms: {\n      account: xdr.lookup(\"LedgerKeyAccount\"),\n      trustLine: xdr.lookup(\"LedgerKeyTrustLine\"),\n      offer: xdr.lookup(\"LedgerKeyOffer\"),\n      data: xdr.lookup(\"LedgerKeyData\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum BucketEntryType\n  //   {\n  //       METAENTRY =\n  //           -1, // At-and-after protocol 11: bucket metadata, should come first.\n  //       LIVEENTRY = 0, // Before protocol 11: created-or-updated;\n  //                      // At-and-after protocol 11: only updated.\n  //       DEADENTRY = 1,\n  //       INITENTRY = 2 // At-and-after protocol 11: only created.\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"BucketEntryType\", {\n    metaentry: -1,\n    liveentry: 0,\n    deadentry: 1,\n    initentry: 2\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"BucketMetadataExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct BucketMetadata\n  //   {\n  //       // Indicates the protocol version used to create / merge this bucket.\n  //       uint32 ledgerVersion;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"BucketMetadata\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"BucketMetadataExt\")]]); // === xdr source ============================================================\n  //\n  //   union BucketEntry switch (BucketEntryType type)\n  //   {\n  //   case LIVEENTRY:\n  //   case INITENTRY:\n  //       LedgerEntry liveEntry;\n  //   \n  //   case DEADENTRY:\n  //       LedgerKey deadEntry;\n  //   case METAENTRY:\n  //       BucketMetadata metaEntry;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"BucketEntry\", {\n    switchOn: xdr.lookup(\"BucketEntryType\"),\n    switchName: \"type\",\n    switches: [[\"liveentry\", \"liveEntry\"], [\"initentry\", \"liveEntry\"], [\"deadentry\", \"deadEntry\"], [\"metaentry\", \"metaEntry\"]],\n    arms: {\n      liveEntry: xdr.lookup(\"LedgerEntry\"),\n      deadEntry: xdr.lookup(\"LedgerKey\"),\n      metaEntry: xdr.lookup(\"BucketMetadata\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionSet\n  //   {\n  //       Hash previousLedgerHash;\n  //       TransactionEnvelope txs<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionSet\", [[\"previousLedgerHash\", xdr.lookup(\"Hash\")], [\"txes\", xdr.varArray(xdr.lookup(\"TransactionEnvelope\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   struct TransactionResultPair\n  //   {\n  //       Hash transactionHash;\n  //       TransactionResult result; // result for the transaction\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionResultPair\", [[\"transactionHash\", xdr.lookup(\"Hash\")], [\"result\", xdr.lookup(\"TransactionResult\")]]); // === xdr source ============================================================\n  //\n  //   struct TransactionResultSet\n  //   {\n  //       TransactionResultPair results<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionResultSet\", [[\"results\", xdr.varArray(xdr.lookup(\"TransactionResultPair\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionHistoryEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionHistoryEntry\n  //   {\n  //       uint32 ledgerSeq;\n  //       TransactionSet txSet;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionHistoryEntry\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"txSet\", xdr.lookup(\"TransactionSet\")], [\"ext\", xdr.lookup(\"TransactionHistoryEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionHistoryResultEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionHistoryResultEntry\n  //   {\n  //       uint32 ledgerSeq;\n  //       TransactionResultSet txResultSet;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionHistoryResultEntry\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"txResultSet\", xdr.lookup(\"TransactionResultSet\")], [\"ext\", xdr.lookup(\"TransactionHistoryResultEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerHeaderHistoryEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerHeaderHistoryEntry\n  //   {\n  //       Hash hash;\n  //       LedgerHeader header;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerHeaderHistoryEntry\", [[\"hash\", xdr.lookup(\"Hash\")], [\"header\", xdr.lookup(\"LedgerHeader\")], [\"ext\", xdr.lookup(\"LedgerHeaderHistoryEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   struct LedgerSCPMessages\n  //   {\n  //       uint32 ledgerSeq;\n  //       SCPEnvelope messages<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerScpMessages\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"messages\", xdr.varArray(xdr.lookup(\"ScpEnvelope\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   struct SCPHistoryEntryV0\n  //   {\n  //       SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages\n  //       LedgerSCPMessages ledgerMessages;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpHistoryEntryV0\", [[\"quorumSets\", xdr.varArray(xdr.lookup(\"ScpQuorumSet\"), 2147483647)], [\"ledgerMessages\", xdr.lookup(\"LedgerScpMessages\")]]); // === xdr source ============================================================\n  //\n  //   union SCPHistoryEntry switch (int v)\n  //   {\n  //   case 0:\n  //       SCPHistoryEntryV0 v0;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ScpHistoryEntry\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"ScpHistoryEntryV0\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum LedgerEntryChangeType\n  //   {\n  //       LEDGER_ENTRY_CREATED = 0, // entry was added to the ledger\n  //       LEDGER_ENTRY_UPDATED = 1, // entry was modified in the ledger\n  //       LEDGER_ENTRY_REMOVED = 2, // entry was removed from the ledger\n  //       LEDGER_ENTRY_STATE = 3    // value of the entry\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"LedgerEntryChangeType\", {\n    ledgerEntryCreated: 0,\n    ledgerEntryUpdated: 1,\n    ledgerEntryRemoved: 2,\n    ledgerEntryState: 3\n  }); // === xdr source ============================================================\n  //\n  //   union LedgerEntryChange switch (LedgerEntryChangeType type)\n  //   {\n  //   case LEDGER_ENTRY_CREATED:\n  //       LedgerEntry created;\n  //   case LEDGER_ENTRY_UPDATED:\n  //       LedgerEntry updated;\n  //   case LEDGER_ENTRY_REMOVED:\n  //       LedgerKey removed;\n  //   case LEDGER_ENTRY_STATE:\n  //       LedgerEntry state;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerEntryChange\", {\n    switchOn: xdr.lookup(\"LedgerEntryChangeType\"),\n    switchName: \"type\",\n    switches: [[\"ledgerEntryCreated\", \"created\"], [\"ledgerEntryUpdated\", \"updated\"], [\"ledgerEntryRemoved\", \"removed\"], [\"ledgerEntryState\", \"state\"]],\n    arms: {\n      created: xdr.lookup(\"LedgerEntry\"),\n      updated: xdr.lookup(\"LedgerEntry\"),\n      removed: xdr.lookup(\"LedgerKey\"),\n      state: xdr.lookup(\"LedgerEntry\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   typedef LedgerEntryChange LedgerEntryChanges<>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"LedgerEntryChanges\", xdr.varArray(xdr.lookup(\"LedgerEntryChange\"), 2147483647)); // === xdr source ============================================================\n  //\n  //   struct OperationMeta\n  //   {\n  //       LedgerEntryChanges changes;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"OperationMeta\", [[\"changes\", xdr.lookup(\"LedgerEntryChanges\")]]); // === xdr source ============================================================\n  //\n  //   struct TransactionMetaV1\n  //   {\n  //       LedgerEntryChanges txChanges; // tx level changes if any\n  //       OperationMeta operations<>;   // meta for each operation\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionMetaV1\", [[\"txChanges\", xdr.lookup(\"LedgerEntryChanges\")], [\"operations\", xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   union TransactionMeta switch (int v)\n  //   {\n  //   case 0:\n  //       OperationMeta operations<>;\n  //   case 1:\n  //       TransactionMetaV1 v1;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionMeta\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"operations\"], [1, \"v1\"]],\n    arms: {\n      operations: xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647),\n      v1: xdr.lookup(\"TransactionMetaV1\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum ErrorCode\n  //   {\n  //       ERR_MISC = 0, // Unspecific error\n  //       ERR_DATA = 1, // Malformed data\n  //       ERR_CONF = 2, // Misconfiguration error\n  //       ERR_AUTH = 3, // Authentication failure\n  //       ERR_LOAD = 4  // System overloaded\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ErrorCode\", {\n    errMisc: 0,\n    errDatum: 1,\n    errConf: 2,\n    errAuth: 3,\n    errLoad: 4\n  }); // === xdr source ============================================================\n  //\n  //   struct Error\n  //   {\n  //       ErrorCode code;\n  //       string msg<100>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Error\", [[\"code\", xdr.lookup(\"ErrorCode\")], [\"msg\", xdr.string(100)]]); // === xdr source ============================================================\n  //\n  //   struct AuthCert\n  //   {\n  //       Curve25519Public pubkey;\n  //       uint64 expiration;\n  //       Signature sig;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AuthCert\", [[\"pubkey\", xdr.lookup(\"Curve25519Public\")], [\"expiration\", xdr.lookup(\"Uint64\")], [\"sig\", xdr.lookup(\"Signature\")]]); // === xdr source ============================================================\n  //\n  //   struct Hello\n  //   {\n  //       uint32 ledgerVersion;\n  //       uint32 overlayVersion;\n  //       uint32 overlayMinVersion;\n  //       Hash networkID;\n  //       string versionStr<100>;\n  //       int listeningPort;\n  //       NodeID peerID;\n  //       AuthCert cert;\n  //       uint256 nonce;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Hello\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"overlayVersion\", xdr.lookup(\"Uint32\")], [\"overlayMinVersion\", xdr.lookup(\"Uint32\")], [\"networkId\", xdr.lookup(\"Hash\")], [\"versionStr\", xdr.string(100)], [\"listeningPort\", xdr.int()], [\"peerId\", xdr.lookup(\"NodeId\")], [\"cert\", xdr.lookup(\"AuthCert\")], [\"nonce\", xdr.lookup(\"Uint256\")]]); // === xdr source ============================================================\n  //\n  //   struct Auth\n  //   {\n  //       // Empty message, just to confirm\n  //       // establishment of MAC keys.\n  //       int unused;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Auth\", [[\"unused\", xdr.int()]]); // === xdr source ============================================================\n  //\n  //   enum IPAddrType\n  //   {\n  //       IPv4 = 0,\n  //       IPv6 = 1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"IpAddrType\", {\n    iPv4: 0,\n    iPv6: 1\n  }); // === xdr source ============================================================\n  //\n  //   union switch (IPAddrType type)\n  //       {\n  //       case IPv4:\n  //           opaque ipv4[4];\n  //       case IPv6:\n  //           opaque ipv6[16];\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"PeerAddressIp\", {\n    switchOn: xdr.lookup(\"IpAddrType\"),\n    switchName: \"type\",\n    switches: [[\"iPv4\", \"ipv4\"], [\"iPv6\", \"ipv6\"]],\n    arms: {\n      ipv4: xdr.opaque(4),\n      ipv6: xdr.opaque(16)\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct PeerAddress\n  //   {\n  //       union switch (IPAddrType type)\n  //       {\n  //       case IPv4:\n  //           opaque ipv4[4];\n  //       case IPv6:\n  //           opaque ipv6[16];\n  //       }\n  //       ip;\n  //       uint32 port;\n  //       uint32 numFailures;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PeerAddress\", [[\"ip\", xdr.lookup(\"PeerAddressIp\")], [\"port\", xdr.lookup(\"Uint32\")], [\"numFailures\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   enum MessageType\n  //   {\n  //       ERROR_MSG = 0,\n  //       AUTH = 2,\n  //       DONT_HAVE = 3,\n  //   \n  //       GET_PEERS = 4, // gets a list of peers this guy knows about\n  //       PEERS = 5,\n  //   \n  //       GET_TX_SET = 6, // gets a particular txset by hash\n  //       TX_SET = 7,\n  //   \n  //       TRANSACTION = 8, // pass on a tx you have heard about\n  //   \n  //       // SCP\n  //       GET_SCP_QUORUMSET = 9,\n  //       SCP_QUORUMSET = 10,\n  //       SCP_MESSAGE = 11,\n  //       GET_SCP_STATE = 12,\n  //   \n  //       // new messages\n  //       HELLO = 13\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"MessageType\", {\n    errorMsg: 0,\n    auth: 2,\n    dontHave: 3,\n    getPeer: 4,\n    peer: 5,\n    getTxSet: 6,\n    txSet: 7,\n    transaction: 8,\n    getScpQuorumset: 9,\n    scpQuorumset: 10,\n    scpMessage: 11,\n    getScpState: 12,\n    hello: 13\n  }); // === xdr source ============================================================\n  //\n  //   struct DontHave\n  //   {\n  //       MessageType type;\n  //       uint256 reqHash;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"DontHave\", [[\"type\", xdr.lookup(\"MessageType\")], [\"reqHash\", xdr.lookup(\"Uint256\")]]); // === xdr source ============================================================\n  //\n  //   union StellarMessage switch (MessageType type)\n  //   {\n  //   case ERROR_MSG:\n  //       Error error;\n  //   case HELLO:\n  //       Hello hello;\n  //   case AUTH:\n  //       Auth auth;\n  //   case DONT_HAVE:\n  //       DontHave dontHave;\n  //   case GET_PEERS:\n  //       void;\n  //   case PEERS:\n  //       PeerAddress peers<100>;\n  //   \n  //   case GET_TX_SET:\n  //       uint256 txSetHash;\n  //   case TX_SET:\n  //       TransactionSet txSet;\n  //   \n  //   case TRANSACTION:\n  //       TransactionEnvelope transaction;\n  //   \n  //   // SCP\n  //   case GET_SCP_QUORUMSET:\n  //       uint256 qSetHash;\n  //   case SCP_QUORUMSET:\n  //       SCPQuorumSet qSet;\n  //   case SCP_MESSAGE:\n  //       SCPEnvelope envelope;\n  //   case GET_SCP_STATE:\n  //       uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"StellarMessage\", {\n    switchOn: xdr.lookup(\"MessageType\"),\n    switchName: \"type\",\n    switches: [[\"errorMsg\", \"error\"], [\"hello\", \"hello\"], [\"auth\", \"auth\"], [\"dontHave\", \"dontHave\"], [\"getPeer\", xdr.void()], [\"peer\", \"peers\"], [\"getTxSet\", \"txSetHash\"], [\"txSet\", \"txSet\"], [\"transaction\", \"transaction\"], [\"getScpQuorumset\", \"qSetHash\"], [\"scpQuorumset\", \"qSet\"], [\"scpMessage\", \"envelope\"], [\"getScpState\", \"getScpLedgerSeq\"]],\n    arms: {\n      error: xdr.lookup(\"Error\"),\n      hello: xdr.lookup(\"Hello\"),\n      auth: xdr.lookup(\"Auth\"),\n      dontHave: xdr.lookup(\"DontHave\"),\n      peers: xdr.varArray(xdr.lookup(\"PeerAddress\"), 100),\n      txSetHash: xdr.lookup(\"Uint256\"),\n      txSet: xdr.lookup(\"TransactionSet\"),\n      transaction: xdr.lookup(\"TransactionEnvelope\"),\n      qSetHash: xdr.lookup(\"Uint256\"),\n      qSet: xdr.lookup(\"ScpQuorumSet\"),\n      envelope: xdr.lookup(\"ScpEnvelope\"),\n      getScpLedgerSeq: xdr.lookup(\"Uint32\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //   {\n  //      uint64 sequence;\n  //      StellarMessage message;\n  //      HmacSha256Mac mac;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AuthenticatedMessageV0\", [[\"sequence\", xdr.lookup(\"Uint64\")], [\"message\", xdr.lookup(\"StellarMessage\")], [\"mac\", xdr.lookup(\"HmacSha256Mac\")]]); // === xdr source ============================================================\n  //\n  //   union AuthenticatedMessage switch (uint32 v)\n  //   {\n  //   case 0:\n  //       struct\n  //   {\n  //      uint64 sequence;\n  //      StellarMessage message;\n  //      HmacSha256Mac mac;\n  //       } v0;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"AuthenticatedMessage\", {\n    switchOn: xdr.lookup(\"Uint32\"),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"AuthenticatedMessageV0\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   typedef opaque Value<>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Value\", xdr.varOpaque()); // === xdr source ============================================================\n  //\n  //   struct SCPBallot\n  //   {\n  //       uint32 counter; // n\n  //       Value value;    // x\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpBallot\", [[\"counter\", xdr.lookup(\"Uint32\")], [\"value\", xdr.lookup(\"Value\")]]); // === xdr source ============================================================\n  //\n  //   enum SCPStatementType\n  //   {\n  //       SCP_ST_PREPARE = 0,\n  //       SCP_ST_CONFIRM = 1,\n  //       SCP_ST_EXTERNALIZE = 2,\n  //       SCP_ST_NOMINATE = 3\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ScpStatementType\", {\n    scpStPrepare: 0,\n    scpStConfirm: 1,\n    scpStExternalize: 2,\n    scpStNominate: 3\n  }); // === xdr source ============================================================\n  //\n  //   struct SCPNomination\n  //   {\n  //       Hash quorumSetHash; // D\n  //       Value votes<>;      // X\n  //       Value accepted<>;   // Y\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpNomination\", [[\"quorumSetHash\", xdr.lookup(\"Hash\")], [\"votes\", xdr.varArray(xdr.lookup(\"Value\"), 2147483647)], [\"accepted\", xdr.varArray(xdr.lookup(\"Value\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpStatementPrepare\", [[\"quorumSetHash\", xdr.lookup(\"Hash\")], [\"ballot\", xdr.lookup(\"ScpBallot\")], [\"prepared\", xdr.option(xdr.lookup(\"ScpBallot\"))], [\"preparedPrime\", xdr.option(xdr.lookup(\"ScpBallot\"))], [\"nC\", xdr.lookup(\"Uint32\")], [\"nH\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpStatementConfirm\", [[\"ballot\", xdr.lookup(\"ScpBallot\")], [\"nPrepared\", xdr.lookup(\"Uint32\")], [\"nCommit\", xdr.lookup(\"Uint32\")], [\"nH\", xdr.lookup(\"Uint32\")], [\"quorumSetHash\", xdr.lookup(\"Hash\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpStatementExternalize\", [[\"commit\", xdr.lookup(\"ScpBallot\")], [\"nH\", xdr.lookup(\"Uint32\")], [\"commitQuorumSetHash\", xdr.lookup(\"Hash\")]]); // === xdr source ============================================================\n  //\n  //   union switch (SCPStatementType type)\n  //       {\n  //       case SCP_ST_PREPARE:\n  //           struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           } prepare;\n  //       case SCP_ST_CONFIRM:\n  //           struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           } confirm;\n  //       case SCP_ST_EXTERNALIZE:\n  //           struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           } externalize;\n  //       case SCP_ST_NOMINATE:\n  //           SCPNomination nominate;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"ScpStatementPledges\", {\n    switchOn: xdr.lookup(\"ScpStatementType\"),\n    switchName: \"type\",\n    switches: [[\"scpStPrepare\", \"prepare\"], [\"scpStConfirm\", \"confirm\"], [\"scpStExternalize\", \"externalize\"], [\"scpStNominate\", \"nominate\"]],\n    arms: {\n      prepare: xdr.lookup(\"ScpStatementPrepare\"),\n      confirm: xdr.lookup(\"ScpStatementConfirm\"),\n      externalize: xdr.lookup(\"ScpStatementExternalize\"),\n      nominate: xdr.lookup(\"ScpNomination\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct SCPStatement\n  //   {\n  //       NodeID nodeID;    // v\n  //       uint64 slotIndex; // i\n  //   \n  //       union switch (SCPStatementType type)\n  //       {\n  //       case SCP_ST_PREPARE:\n  //           struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           } prepare;\n  //       case SCP_ST_CONFIRM:\n  //           struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           } confirm;\n  //       case SCP_ST_EXTERNALIZE:\n  //           struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           } externalize;\n  //       case SCP_ST_NOMINATE:\n  //           SCPNomination nominate;\n  //       }\n  //       pledges;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpStatement\", [[\"nodeId\", xdr.lookup(\"NodeId\")], [\"slotIndex\", xdr.lookup(\"Uint64\")], [\"pledges\", xdr.lookup(\"ScpStatementPledges\")]]); // === xdr source ============================================================\n  //\n  //   struct SCPEnvelope\n  //   {\n  //       SCPStatement statement;\n  //       Signature signature;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpEnvelope\", [[\"statement\", xdr.lookup(\"ScpStatement\")], [\"signature\", xdr.lookup(\"Signature\")]]); // === xdr source ============================================================\n  //\n  //   struct SCPQuorumSet\n  //   {\n  //       uint32 threshold;\n  //       PublicKey validators<>;\n  //       SCPQuorumSet innerSets<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpQuorumSet\", [[\"threshold\", xdr.lookup(\"Uint32\")], [\"validators\", xdr.varArray(xdr.lookup(\"PublicKey\"), 2147483647)], [\"innerSets\", xdr.varArray(xdr.lookup(\"ScpQuorumSet\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   struct DecoratedSignature\n  //   {\n  //       SignatureHint hint;  // last 4 bytes of the public key, used as a hint\n  //       Signature signature; // actual signature\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"DecoratedSignature\", [[\"hint\", xdr.lookup(\"SignatureHint\")], [\"signature\", xdr.lookup(\"Signature\")]]); // === xdr source ============================================================\n  //\n  //   enum OperationType\n  //   {\n  //       CREATE_ACCOUNT = 0,\n  //       PAYMENT = 1,\n  //       PATH_PAYMENT = 2,\n  //       MANAGE_SELL_OFFER = 3,\n  //       CREATE_PASSIVE_SELL_OFFER = 4,\n  //       SET_OPTIONS = 5,\n  //       CHANGE_TRUST = 6,\n  //       ALLOW_TRUST = 7,\n  //       ACCOUNT_MERGE = 8,\n  //       INFLATION = 9,\n  //       MANAGE_DATA = 10,\n  //       BUMP_SEQUENCE = 11,\n  //       MANAGE_BUY_OFFER = 12\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"OperationType\", {\n    createAccount: 0,\n    payment: 1,\n    pathPayment: 2,\n    manageSellOffer: 3,\n    createPassiveSellOffer: 4,\n    setOption: 5,\n    changeTrust: 6,\n    allowTrust: 7,\n    accountMerge: 8,\n    inflation: 9,\n    manageDatum: 10,\n    bumpSequence: 11,\n    manageBuyOffer: 12\n  }); // === xdr source ============================================================\n  //\n  //   struct CreateAccountOp\n  //   {\n  //       AccountID destination; // account to create\n  //       int64 startingBalance; // amount they end up with\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"CreateAccountOp\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"startingBalance\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct PaymentOp\n  //   {\n  //       AccountID destination; // recipient of the payment\n  //       Asset asset;           // what they end up with\n  //       int64 amount;          // amount they end up with\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PaymentOp\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct PathPaymentOp\n  //   {\n  //       Asset sendAsset; // asset we pay with\n  //       int64 sendMax;   // the maximum amount of sendAsset to\n  //                        // send (excluding fees).\n  //                        // The operation will fail if can't be met\n  //   \n  //       AccountID destination; // recipient of the payment\n  //       Asset destAsset;       // what they end up with\n  //       int64 destAmount;      // amount they end up with\n  //   \n  //       Asset path<5>; // additional hops it must go through to get there\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PathPaymentOp\", [[\"sendAsset\", xdr.lookup(\"Asset\")], [\"sendMax\", xdr.lookup(\"Int64\")], [\"destination\", xdr.lookup(\"AccountId\")], [\"destAsset\", xdr.lookup(\"Asset\")], [\"destAmount\", xdr.lookup(\"Int64\")], [\"path\", xdr.varArray(xdr.lookup(\"Asset\"), 5)]]); // === xdr source ============================================================\n  //\n  //   struct ManageSellOfferOp\n  //   {\n  //       Asset selling;\n  //       Asset buying;\n  //       int64 amount; // amount being sold. if set to 0, delete the offer\n  //       Price price;  // price of thing being sold in terms of what you are buying\n  //   \n  //       // 0=create a new offer, otherwise edit an existing offer\n  //       int64 offerID;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ManageSellOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"offerId\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct ManageBuyOfferOp\n  //   {\n  //       Asset selling;\n  //       Asset buying;\n  //       int64 buyAmount; // amount being bought. if set to 0, delete the offer\n  //       Price price;     // price of thing being bought in terms of what you are\n  //                        // selling\n  //   \n  //       // 0=create a new offer, otherwise edit an existing offer\n  //       int64 offerID;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ManageBuyOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"buyAmount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"offerId\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct CreatePassiveSellOfferOp\n  //   {\n  //       Asset selling; // A\n  //       Asset buying;  // B\n  //       int64 amount;  // amount taker gets. if set to 0, delete the offer\n  //       Price price;   // cost of A in terms of B\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"CreatePassiveSellOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")]]); // === xdr source ============================================================\n  //\n  //   struct SetOptionsOp\n  //   {\n  //       AccountID* inflationDest; // sets the inflation destination\n  //   \n  //       uint32* clearFlags; // which flags to clear\n  //       uint32* setFlags;   // which flags to set\n  //   \n  //       // account threshold manipulation\n  //       uint32* masterWeight; // weight of the master account\n  //       uint32* lowThreshold;\n  //       uint32* medThreshold;\n  //       uint32* highThreshold;\n  //   \n  //       string32* homeDomain; // sets the home domain\n  //   \n  //       // Add, update or remove a signer for the account\n  //       // signer is deleted if the weight is 0\n  //       Signer* signer;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"SetOptionsOp\", [[\"inflationDest\", xdr.option(xdr.lookup(\"AccountId\"))], [\"clearFlags\", xdr.option(xdr.lookup(\"Uint32\"))], [\"setFlags\", xdr.option(xdr.lookup(\"Uint32\"))], [\"masterWeight\", xdr.option(xdr.lookup(\"Uint32\"))], [\"lowThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"medThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"highThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"homeDomain\", xdr.option(xdr.lookup(\"String32\"))], [\"signer\", xdr.option(xdr.lookup(\"Signer\"))]]); // === xdr source ============================================================\n  //\n  //   struct ChangeTrustOp\n  //   {\n  //       Asset line;\n  //   \n  //       // if limit is set to 0, deletes the trust line\n  //       int64 limit;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ChangeTrustOp\", [[\"line\", xdr.lookup(\"Asset\")], [\"limit\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   union switch (AssetType type)\n  //       {\n  //       // ASSET_TYPE_NATIVE is not allowed\n  //       case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //           AssetCode4 assetCode4;\n  //   \n  //       case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //           AssetCode12 assetCode12;\n  //   \n  //           // add other asset types here in the future\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"AllowTrustOpAsset\", {\n    switchOn: xdr.lookup(\"AssetType\"),\n    switchName: \"type\",\n    switches: [[\"assetTypeCreditAlphanum4\", \"assetCode4\"], [\"assetTypeCreditAlphanum12\", \"assetCode12\"]],\n    arms: {\n      assetCode4: xdr.lookup(\"AssetCode4\"),\n      assetCode12: xdr.lookup(\"AssetCode12\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct AllowTrustOp\n  //   {\n  //       AccountID trustor;\n  //       union switch (AssetType type)\n  //       {\n  //       // ASSET_TYPE_NATIVE is not allowed\n  //       case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //           AssetCode4 assetCode4;\n  //   \n  //       case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //           AssetCode12 assetCode12;\n  //   \n  //           // add other asset types here in the future\n  //       }\n  //       asset;\n  //   \n  //       bool authorize;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AllowTrustOp\", [[\"trustor\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"AllowTrustOpAsset\")], [\"authorize\", xdr.bool()]]); // === xdr source ============================================================\n  //\n  //   struct ManageDataOp\n  //   {\n  //       string64 dataName;\n  //       DataValue* dataValue; // set to null to clear\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ManageDataOp\", [[\"dataName\", xdr.lookup(\"String64\")], [\"dataValue\", xdr.option(xdr.lookup(\"DataValue\"))]]); // === xdr source ============================================================\n  //\n  //   struct BumpSequenceOp\n  //   {\n  //       SequenceNumber bumpTo;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"BumpSequenceOp\", [[\"bumpTo\", xdr.lookup(\"SequenceNumber\")]]); // === xdr source ============================================================\n  //\n  //   union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountOp createAccountOp;\n  //       case PAYMENT:\n  //           PaymentOp paymentOp;\n  //       case PATH_PAYMENT:\n  //           PathPaymentOp pathPaymentOp;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferOp manageSellOfferOp;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           CreatePassiveSellOfferOp createPassiveSellOfferOp;\n  //       case SET_OPTIONS:\n  //           SetOptionsOp setOptionsOp;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustOp changeTrustOp;\n  //       case ALLOW_TRUST:\n  //           AllowTrustOp allowTrustOp;\n  //       case ACCOUNT_MERGE:\n  //           AccountID destination;\n  //       case INFLATION:\n  //           void;\n  //       case MANAGE_DATA:\n  //           ManageDataOp manageDataOp;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceOp bumpSequenceOp;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferOp manageBuyOfferOp;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"OperationBody\", {\n    switchOn: xdr.lookup(\"OperationType\"),\n    switchName: \"type\",\n    switches: [[\"createAccount\", \"createAccountOp\"], [\"payment\", \"paymentOp\"], [\"pathPayment\", \"pathPaymentOp\"], [\"manageSellOffer\", \"manageSellOfferOp\"], [\"createPassiveSellOffer\", \"createPassiveSellOfferOp\"], [\"setOption\", \"setOptionsOp\"], [\"changeTrust\", \"changeTrustOp\"], [\"allowTrust\", \"allowTrustOp\"], [\"accountMerge\", \"destination\"], [\"inflation\", xdr.void()], [\"manageDatum\", \"manageDataOp\"], [\"bumpSequence\", \"bumpSequenceOp\"], [\"manageBuyOffer\", \"manageBuyOfferOp\"]],\n    arms: {\n      createAccountOp: xdr.lookup(\"CreateAccountOp\"),\n      paymentOp: xdr.lookup(\"PaymentOp\"),\n      pathPaymentOp: xdr.lookup(\"PathPaymentOp\"),\n      manageSellOfferOp: xdr.lookup(\"ManageSellOfferOp\"),\n      createPassiveSellOfferOp: xdr.lookup(\"CreatePassiveSellOfferOp\"),\n      setOptionsOp: xdr.lookup(\"SetOptionsOp\"),\n      changeTrustOp: xdr.lookup(\"ChangeTrustOp\"),\n      allowTrustOp: xdr.lookup(\"AllowTrustOp\"),\n      destination: xdr.lookup(\"AccountId\"),\n      manageDataOp: xdr.lookup(\"ManageDataOp\"),\n      bumpSequenceOp: xdr.lookup(\"BumpSequenceOp\"),\n      manageBuyOfferOp: xdr.lookup(\"ManageBuyOfferOp\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct Operation\n  //   {\n  //       // sourceAccount is the account used to run the operation\n  //       // if not set, the runtime defaults to \"sourceAccount\" specified at\n  //       // the transaction level\n  //       AccountID* sourceAccount;\n  //   \n  //       union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountOp createAccountOp;\n  //       case PAYMENT:\n  //           PaymentOp paymentOp;\n  //       case PATH_PAYMENT:\n  //           PathPaymentOp pathPaymentOp;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferOp manageSellOfferOp;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           CreatePassiveSellOfferOp createPassiveSellOfferOp;\n  //       case SET_OPTIONS:\n  //           SetOptionsOp setOptionsOp;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustOp changeTrustOp;\n  //       case ALLOW_TRUST:\n  //           AllowTrustOp allowTrustOp;\n  //       case ACCOUNT_MERGE:\n  //           AccountID destination;\n  //       case INFLATION:\n  //           void;\n  //       case MANAGE_DATA:\n  //           ManageDataOp manageDataOp;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceOp bumpSequenceOp;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferOp manageBuyOfferOp;\n  //       }\n  //       body;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Operation\", [[\"sourceAccount\", xdr.option(xdr.lookup(\"AccountId\"))], [\"body\", xdr.lookup(\"OperationBody\")]]); // === xdr source ============================================================\n  //\n  //   enum MemoType\n  //   {\n  //       MEMO_NONE = 0,\n  //       MEMO_TEXT = 1,\n  //       MEMO_ID = 2,\n  //       MEMO_HASH = 3,\n  //       MEMO_RETURN = 4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"MemoType\", {\n    memoNone: 0,\n    memoText: 1,\n    memoId: 2,\n    memoHash: 3,\n    memoReturn: 4\n  }); // === xdr source ============================================================\n  //\n  //   union Memo switch (MemoType type)\n  //   {\n  //   case MEMO_NONE:\n  //       void;\n  //   case MEMO_TEXT:\n  //       string text<28>;\n  //   case MEMO_ID:\n  //       uint64 id;\n  //   case MEMO_HASH:\n  //       Hash hash; // the hash of what to pull from the content server\n  //   case MEMO_RETURN:\n  //       Hash retHash; // the hash of the tx you are rejecting\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"Memo\", {\n    switchOn: xdr.lookup(\"MemoType\"),\n    switchName: \"type\",\n    switches: [[\"memoNone\", xdr.void()], [\"memoText\", \"text\"], [\"memoId\", \"id\"], [\"memoHash\", \"hash\"], [\"memoReturn\", \"retHash\"]],\n    arms: {\n      text: xdr.string(28),\n      id: xdr.lookup(\"Uint64\"),\n      hash: xdr.lookup(\"Hash\"),\n      retHash: xdr.lookup(\"Hash\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TimeBounds\n  //   {\n  //       TimePoint minTime;\n  //       TimePoint maxTime; // 0 here means no maxTime\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TimeBounds\", [[\"minTime\", xdr.lookup(\"TimePoint\")], [\"maxTime\", xdr.lookup(\"TimePoint\")]]); // === xdr source ============================================================\n  //\n  //   const MAX_OPS_PER_TX = 100;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MAX_OPS_PER_TX\", 100); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct Transaction\n  //   {\n  //       // account used to run the transaction\n  //       AccountID sourceAccount;\n  //   \n  //       // the fee the sourceAccount will pay\n  //       uint32 fee;\n  //   \n  //       // sequence number to consume in the account\n  //       SequenceNumber seqNum;\n  //   \n  //       // validity range (inclusive) for the last ledger close time\n  //       TimeBounds* timeBounds;\n  //   \n  //       Memo memo;\n  //   \n  //       Operation operations<MAX_OPS_PER_TX>;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Transaction\", [[\"sourceAccount\", xdr.lookup(\"AccountId\")], [\"fee\", xdr.lookup(\"Uint32\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"timeBounds\", xdr.option(xdr.lookup(\"TimeBounds\"))], [\"memo\", xdr.lookup(\"Memo\")], [\"operations\", xdr.varArray(xdr.lookup(\"Operation\"), xdr.lookup(\"MAX_OPS_PER_TX\"))], [\"ext\", xdr.lookup(\"TransactionExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (EnvelopeType type)\n  //       {\n  //       case ENVELOPE_TYPE_TX:\n  //           Transaction tx;\n  //           /* All other values of type are invalid */\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionSignaturePayloadTaggedTransaction\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeTx\", \"tx\"]],\n    arms: {\n      tx: xdr.lookup(\"Transaction\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionSignaturePayload\n  //   {\n  //       Hash networkId;\n  //       union switch (EnvelopeType type)\n  //       {\n  //       case ENVELOPE_TYPE_TX:\n  //           Transaction tx;\n  //           /* All other values of type are invalid */\n  //       }\n  //       taggedTransaction;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionSignaturePayload\", [[\"networkId\", xdr.lookup(\"Hash\")], [\"taggedTransaction\", xdr.lookup(\"TransactionSignaturePayloadTaggedTransaction\")]]); // === xdr source ============================================================\n  //\n  //   struct TransactionEnvelope\n  //   {\n  //       Transaction tx;\n  //       /* Each decorated signature is a signature over the SHA256 hash of\n  //        * a TransactionSignaturePayload */\n  //       DecoratedSignature signatures<20>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionEnvelope\", [[\"tx\", xdr.lookup(\"Transaction\")], [\"signatures\", xdr.varArray(xdr.lookup(\"DecoratedSignature\"), 20)]]); // === xdr source ============================================================\n  //\n  //   struct ClaimOfferAtom\n  //   {\n  //       // emitted to identify the offer\n  //       AccountID sellerID; // Account that owns the offer\n  //       int64 offerID;\n  //   \n  //       // amount and asset taken from the owner\n  //       Asset assetSold;\n  //       int64 amountSold;\n  //   \n  //       // amount and asset sent to the owner\n  //       Asset assetBought;\n  //       int64 amountBought;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ClaimOfferAtom\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")], [\"assetSold\", xdr.lookup(\"Asset\")], [\"amountSold\", xdr.lookup(\"Int64\")], [\"assetBought\", xdr.lookup(\"Asset\")], [\"amountBought\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   enum CreateAccountResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       CREATE_ACCOUNT_SUCCESS = 0, // account was created\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       CREATE_ACCOUNT_MALFORMED = -1,   // invalid destination\n  //       CREATE_ACCOUNT_UNDERFUNDED = -2, // not enough funds in source account\n  //       CREATE_ACCOUNT_LOW_RESERVE =\n  //           -3, // would create an account below the min reserve\n  //       CREATE_ACCOUNT_ALREADY_EXIST = -4 // account already exists\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"CreateAccountResultCode\", {\n    createAccountSuccess: 0,\n    createAccountMalformed: -1,\n    createAccountUnderfunded: -2,\n    createAccountLowReserve: -3,\n    createAccountAlreadyExist: -4\n  }); // === xdr source ============================================================\n  //\n  //   union CreateAccountResult switch (CreateAccountResultCode code)\n  //   {\n  //   case CREATE_ACCOUNT_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"CreateAccountResult\", {\n    switchOn: xdr.lookup(\"CreateAccountResultCode\"),\n    switchName: \"code\",\n    switches: [[\"createAccountSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum PaymentResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PAYMENT_SUCCESS = 0, // payment successfuly completed\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PAYMENT_MALFORMED = -1,          // bad input\n  //       PAYMENT_UNDERFUNDED = -2,        // not enough funds in source account\n  //       PAYMENT_SRC_NO_TRUST = -3,       // no trust line on source account\n  //       PAYMENT_SRC_NOT_AUTHORIZED = -4, // source not authorized to transfer\n  //       PAYMENT_NO_DESTINATION = -5,     // destination account does not exist\n  //       PAYMENT_NO_TRUST = -6,       // destination missing a trust line for asset\n  //       PAYMENT_NOT_AUTHORIZED = -7, // destination not authorized to hold asset\n  //       PAYMENT_LINE_FULL = -8,      // destination would go above their limit\n  //       PAYMENT_NO_ISSUER = -9       // missing issuer on asset\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"PaymentResultCode\", {\n    paymentSuccess: 0,\n    paymentMalformed: -1,\n    paymentUnderfunded: -2,\n    paymentSrcNoTrust: -3,\n    paymentSrcNotAuthorized: -4,\n    paymentNoDestination: -5,\n    paymentNoTrust: -6,\n    paymentNotAuthorized: -7,\n    paymentLineFull: -8,\n    paymentNoIssuer: -9\n  }); // === xdr source ============================================================\n  //\n  //   union PaymentResult switch (PaymentResultCode code)\n  //   {\n  //   case PAYMENT_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"PaymentResult\", {\n    switchOn: xdr.lookup(\"PaymentResultCode\"),\n    switchName: \"code\",\n    switches: [[\"paymentSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum PathPaymentResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PATH_PAYMENT_SUCCESS = 0, // success\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PATH_PAYMENT_MALFORMED = -1,          // bad input\n  //       PATH_PAYMENT_UNDERFUNDED = -2,        // not enough funds in source account\n  //       PATH_PAYMENT_SRC_NO_TRUST = -3,       // no trust line on source account\n  //       PATH_PAYMENT_SRC_NOT_AUTHORIZED = -4, // source not authorized to transfer\n  //       PATH_PAYMENT_NO_DESTINATION = -5,     // destination account does not exist\n  //       PATH_PAYMENT_NO_TRUST = -6,           // dest missing a trust line for asset\n  //       PATH_PAYMENT_NOT_AUTHORIZED = -7,     // dest not authorized to hold asset\n  //       PATH_PAYMENT_LINE_FULL = -8,          // dest would go above their limit\n  //       PATH_PAYMENT_NO_ISSUER = -9,          // missing issuer on one asset\n  //       PATH_PAYMENT_TOO_FEW_OFFERS = -10,    // not enough offers to satisfy path\n  //       PATH_PAYMENT_OFFER_CROSS_SELF = -11,  // would cross one of its own offers\n  //       PATH_PAYMENT_OVER_SENDMAX = -12       // could not satisfy sendmax\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"PathPaymentResultCode\", {\n    pathPaymentSuccess: 0,\n    pathPaymentMalformed: -1,\n    pathPaymentUnderfunded: -2,\n    pathPaymentSrcNoTrust: -3,\n    pathPaymentSrcNotAuthorized: -4,\n    pathPaymentNoDestination: -5,\n    pathPaymentNoTrust: -6,\n    pathPaymentNotAuthorized: -7,\n    pathPaymentLineFull: -8,\n    pathPaymentNoIssuer: -9,\n    pathPaymentTooFewOffer: -10,\n    pathPaymentOfferCrossSelf: -11,\n    pathPaymentOverSendmax: -12\n  }); // === xdr source ============================================================\n  //\n  //   struct SimplePaymentResult\n  //   {\n  //       AccountID destination;\n  //       Asset asset;\n  //       int64 amount;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"SimplePaymentResult\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PathPaymentResultSuccess\", [[\"offers\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"last\", xdr.lookup(\"SimplePaymentResult\")]]); // === xdr source ============================================================\n  //\n  //   union PathPaymentResult switch (PathPaymentResultCode code)\n  //   {\n  //   case PATH_PAYMENT_SUCCESS:\n  //       struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       } success;\n  //   case PATH_PAYMENT_NO_ISSUER:\n  //       Asset noIssuer; // the asset that caused the error\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"PathPaymentResult\", {\n    switchOn: xdr.lookup(\"PathPaymentResultCode\"),\n    switchName: \"code\",\n    switches: [[\"pathPaymentSuccess\", \"success\"], [\"pathPaymentNoIssuer\", \"noIssuer\"]],\n    arms: {\n      success: xdr.lookup(\"PathPaymentResultSuccess\"),\n      noIssuer: xdr.lookup(\"Asset\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ManageSellOfferResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_SELL_OFFER_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_SELL_OFFER_MALFORMED = -1,     // generated offer would be invalid\n  //       MANAGE_SELL_OFFER_SELL_NO_TRUST = -2, // no trust line for what we're selling\n  //       MANAGE_SELL_OFFER_BUY_NO_TRUST = -3,  // no trust line for what we're buying\n  //       MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell\n  //       MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy\n  //       MANAGE_SELL_OFFER_LINE_FULL = -6,      // can't receive more of what it's buying\n  //       MANAGE_SELL_OFFER_UNDERFUNDED = -7,    // doesn't hold what it's trying to sell\n  //       MANAGE_SELL_OFFER_CROSS_SELF = -8,     // would cross an offer from the same user\n  //       MANAGE_SELL_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling\n  //       MANAGE_SELL_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying\n  //   \n  //       // update errors\n  //       MANAGE_SELL_OFFER_NOT_FOUND = -11, // offerID does not match an existing offer\n  //   \n  //       MANAGE_SELL_OFFER_LOW_RESERVE = -12 // not enough funds to create a new Offer\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ManageSellOfferResultCode\", {\n    manageSellOfferSuccess: 0,\n    manageSellOfferMalformed: -1,\n    manageSellOfferSellNoTrust: -2,\n    manageSellOfferBuyNoTrust: -3,\n    manageSellOfferSellNotAuthorized: -4,\n    manageSellOfferBuyNotAuthorized: -5,\n    manageSellOfferLineFull: -6,\n    manageSellOfferUnderfunded: -7,\n    manageSellOfferCrossSelf: -8,\n    manageSellOfferSellNoIssuer: -9,\n    manageSellOfferBuyNoIssuer: -10,\n    manageSellOfferNotFound: -11,\n    manageSellOfferLowReserve: -12\n  }); // === xdr source ============================================================\n  //\n  //   enum ManageOfferEffect\n  //   {\n  //       MANAGE_OFFER_CREATED = 0,\n  //       MANAGE_OFFER_UPDATED = 1,\n  //       MANAGE_OFFER_DELETED = 2\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ManageOfferEffect\", {\n    manageOfferCreated: 0,\n    manageOfferUpdated: 1,\n    manageOfferDeleted: 2\n  }); // === xdr source ============================================================\n  //\n  //   union switch (ManageOfferEffect effect)\n  //       {\n  //       case MANAGE_OFFER_CREATED:\n  //       case MANAGE_OFFER_UPDATED:\n  //           OfferEntry offer;\n  //       default:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"ManageOfferSuccessResultOffer\", {\n    switchOn: xdr.lookup(\"ManageOfferEffect\"),\n    switchName: \"effect\",\n    switches: [[\"manageOfferCreated\", \"offer\"], [\"manageOfferUpdated\", \"offer\"]],\n    arms: {\n      offer: xdr.lookup(\"OfferEntry\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   struct ManageOfferSuccessResult\n  //   {\n  //       // offers that got claimed while creating this offer\n  //       ClaimOfferAtom offersClaimed<>;\n  //   \n  //       union switch (ManageOfferEffect effect)\n  //       {\n  //       case MANAGE_OFFER_CREATED:\n  //       case MANAGE_OFFER_UPDATED:\n  //           OfferEntry offer;\n  //       default:\n  //           void;\n  //       }\n  //       offer;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ManageOfferSuccessResult\", [[\"offersClaimed\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"offer\", xdr.lookup(\"ManageOfferSuccessResultOffer\")]]); // === xdr source ============================================================\n  //\n  //   union ManageSellOfferResult switch (ManageSellOfferResultCode code)\n  //   {\n  //   case MANAGE_SELL_OFFER_SUCCESS:\n  //       ManageOfferSuccessResult success;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ManageSellOfferResult\", {\n    switchOn: xdr.lookup(\"ManageSellOfferResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageSellOfferSuccess\", \"success\"]],\n    arms: {\n      success: xdr.lookup(\"ManageOfferSuccessResult\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ManageBuyOfferResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_BUY_OFFER_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_BUY_OFFER_MALFORMED = -1,     // generated offer would be invalid\n  //       MANAGE_BUY_OFFER_SELL_NO_TRUST = -2, // no trust line for what we're selling\n  //       MANAGE_BUY_OFFER_BUY_NO_TRUST = -3,  // no trust line for what we're buying\n  //       MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell\n  //       MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy\n  //       MANAGE_BUY_OFFER_LINE_FULL = -6,      // can't receive more of what it's buying\n  //       MANAGE_BUY_OFFER_UNDERFUNDED = -7,    // doesn't hold what it's trying to sell\n  //       MANAGE_BUY_OFFER_CROSS_SELF = -8,     // would cross an offer from the same user\n  //       MANAGE_BUY_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling\n  //       MANAGE_BUY_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying\n  //   \n  //       // update errors\n  //       MANAGE_BUY_OFFER_NOT_FOUND = -11, // offerID does not match an existing offer\n  //   \n  //       MANAGE_BUY_OFFER_LOW_RESERVE = -12 // not enough funds to create a new Offer\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ManageBuyOfferResultCode\", {\n    manageBuyOfferSuccess: 0,\n    manageBuyOfferMalformed: -1,\n    manageBuyOfferSellNoTrust: -2,\n    manageBuyOfferBuyNoTrust: -3,\n    manageBuyOfferSellNotAuthorized: -4,\n    manageBuyOfferBuyNotAuthorized: -5,\n    manageBuyOfferLineFull: -6,\n    manageBuyOfferUnderfunded: -7,\n    manageBuyOfferCrossSelf: -8,\n    manageBuyOfferSellNoIssuer: -9,\n    manageBuyOfferBuyNoIssuer: -10,\n    manageBuyOfferNotFound: -11,\n    manageBuyOfferLowReserve: -12\n  }); // === xdr source ============================================================\n  //\n  //   union ManageBuyOfferResult switch (ManageBuyOfferResultCode code)\n  //   {\n  //   case MANAGE_BUY_OFFER_SUCCESS:\n  //       ManageOfferSuccessResult success;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ManageBuyOfferResult\", {\n    switchOn: xdr.lookup(\"ManageBuyOfferResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageBuyOfferSuccess\", \"success\"]],\n    arms: {\n      success: xdr.lookup(\"ManageOfferSuccessResult\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum SetOptionsResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       SET_OPTIONS_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       SET_OPTIONS_LOW_RESERVE = -1,      // not enough funds to add a signer\n  //       SET_OPTIONS_TOO_MANY_SIGNERS = -2, // max number of signers already reached\n  //       SET_OPTIONS_BAD_FLAGS = -3,        // invalid combination of clear/set flags\n  //       SET_OPTIONS_INVALID_INFLATION = -4,      // inflation account does not exist\n  //       SET_OPTIONS_CANT_CHANGE = -5,            // can no longer change this option\n  //       SET_OPTIONS_UNKNOWN_FLAG = -6,           // can't set an unknown flag\n  //       SET_OPTIONS_THRESHOLD_OUT_OF_RANGE = -7, // bad value for weight/threshold\n  //       SET_OPTIONS_BAD_SIGNER = -8,             // signer cannot be masterkey\n  //       SET_OPTIONS_INVALID_HOME_DOMAIN = -9     // malformed home domain\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"SetOptionsResultCode\", {\n    setOptionsSuccess: 0,\n    setOptionsLowReserve: -1,\n    setOptionsTooManySigner: -2,\n    setOptionsBadFlag: -3,\n    setOptionsInvalidInflation: -4,\n    setOptionsCantChange: -5,\n    setOptionsUnknownFlag: -6,\n    setOptionsThresholdOutOfRange: -7,\n    setOptionsBadSigner: -8,\n    setOptionsInvalidHomeDomain: -9\n  }); // === xdr source ============================================================\n  //\n  //   union SetOptionsResult switch (SetOptionsResultCode code)\n  //   {\n  //   case SET_OPTIONS_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"SetOptionsResult\", {\n    switchOn: xdr.lookup(\"SetOptionsResultCode\"),\n    switchName: \"code\",\n    switches: [[\"setOptionsSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ChangeTrustResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       CHANGE_TRUST_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       CHANGE_TRUST_MALFORMED = -1,     // bad input\n  //       CHANGE_TRUST_NO_ISSUER = -2,     // could not find issuer\n  //       CHANGE_TRUST_INVALID_LIMIT = -3, // cannot drop limit below balance\n  //                                        // cannot create with a limit of 0\n  //       CHANGE_TRUST_LOW_RESERVE =\n  //           -4, // not enough funds to create a new trust line,\n  //       CHANGE_TRUST_SELF_NOT_ALLOWED = -5  // trusting self is not allowed\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ChangeTrustResultCode\", {\n    changeTrustSuccess: 0,\n    changeTrustMalformed: -1,\n    changeTrustNoIssuer: -2,\n    changeTrustInvalidLimit: -3,\n    changeTrustLowReserve: -4,\n    changeTrustSelfNotAllowed: -5\n  }); // === xdr source ============================================================\n  //\n  //   union ChangeTrustResult switch (ChangeTrustResultCode code)\n  //   {\n  //   case CHANGE_TRUST_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ChangeTrustResult\", {\n    switchOn: xdr.lookup(\"ChangeTrustResultCode\"),\n    switchName: \"code\",\n    switches: [[\"changeTrustSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum AllowTrustResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       ALLOW_TRUST_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       ALLOW_TRUST_MALFORMED = -1,     // asset is not ASSET_TYPE_ALPHANUM\n  //       ALLOW_TRUST_NO_TRUST_LINE = -2, // trustor does not have a trustline\n  //                                       // source account does not require trust\n  //       ALLOW_TRUST_TRUST_NOT_REQUIRED = -3,\n  //       ALLOW_TRUST_CANT_REVOKE = -4,     // source account can't revoke trust,\n  //       ALLOW_TRUST_SELF_NOT_ALLOWED = -5 // trusting self is not allowed\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"AllowTrustResultCode\", {\n    allowTrustSuccess: 0,\n    allowTrustMalformed: -1,\n    allowTrustNoTrustLine: -2,\n    allowTrustTrustNotRequired: -3,\n    allowTrustCantRevoke: -4,\n    allowTrustSelfNotAllowed: -5\n  }); // === xdr source ============================================================\n  //\n  //   union AllowTrustResult switch (AllowTrustResultCode code)\n  //   {\n  //   case ALLOW_TRUST_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"AllowTrustResult\", {\n    switchOn: xdr.lookup(\"AllowTrustResultCode\"),\n    switchName: \"code\",\n    switches: [[\"allowTrustSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum AccountMergeResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       ACCOUNT_MERGE_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       ACCOUNT_MERGE_MALFORMED = -1,       // can't merge onto itself\n  //       ACCOUNT_MERGE_NO_ACCOUNT = -2,      // destination does not exist\n  //       ACCOUNT_MERGE_IMMUTABLE_SET = -3,   // source account has AUTH_IMMUTABLE set\n  //       ACCOUNT_MERGE_HAS_SUB_ENTRIES = -4, // account has trust lines/offers\n  //       ACCOUNT_MERGE_SEQNUM_TOO_FAR = -5,  // sequence number is over max allowed\n  //       ACCOUNT_MERGE_DEST_FULL = -6        // can't add source balance to\n  //                                           // destination balance\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"AccountMergeResultCode\", {\n    accountMergeSuccess: 0,\n    accountMergeMalformed: -1,\n    accountMergeNoAccount: -2,\n    accountMergeImmutableSet: -3,\n    accountMergeHasSubEntry: -4,\n    accountMergeSeqnumTooFar: -5,\n    accountMergeDestFull: -6\n  }); // === xdr source ============================================================\n  //\n  //   union AccountMergeResult switch (AccountMergeResultCode code)\n  //   {\n  //   case ACCOUNT_MERGE_SUCCESS:\n  //       int64 sourceAccountBalance; // how much got transfered from source account\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"AccountMergeResult\", {\n    switchOn: xdr.lookup(\"AccountMergeResultCode\"),\n    switchName: \"code\",\n    switches: [[\"accountMergeSuccess\", \"sourceAccountBalance\"]],\n    arms: {\n      sourceAccountBalance: xdr.lookup(\"Int64\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum InflationResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       INFLATION_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       INFLATION_NOT_TIME = -1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"InflationResultCode\", {\n    inflationSuccess: 0,\n    inflationNotTime: -1\n  }); // === xdr source ============================================================\n  //\n  //   struct InflationPayout // or use PaymentResultAtom to limit types?\n  //   {\n  //       AccountID destination;\n  //       int64 amount;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"InflationPayout\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"amount\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   union InflationResult switch (InflationResultCode code)\n  //   {\n  //   case INFLATION_SUCCESS:\n  //       InflationPayout payouts<>;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"InflationResult\", {\n    switchOn: xdr.lookup(\"InflationResultCode\"),\n    switchName: \"code\",\n    switches: [[\"inflationSuccess\", \"payouts\"]],\n    arms: {\n      payouts: xdr.varArray(xdr.lookup(\"InflationPayout\"), 2147483647)\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ManageDataResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_DATA_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_DATA_NOT_SUPPORTED_YET =\n  //           -1, // The network hasn't moved to this protocol change yet\n  //       MANAGE_DATA_NAME_NOT_FOUND =\n  //           -2, // Trying to remove a Data Entry that isn't there\n  //       MANAGE_DATA_LOW_RESERVE = -3, // not enough funds to create a new Data Entry\n  //       MANAGE_DATA_INVALID_NAME = -4 // Name not a valid string\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ManageDataResultCode\", {\n    manageDataSuccess: 0,\n    manageDataNotSupportedYet: -1,\n    manageDataNameNotFound: -2,\n    manageDataLowReserve: -3,\n    manageDataInvalidName: -4\n  }); // === xdr source ============================================================\n  //\n  //   union ManageDataResult switch (ManageDataResultCode code)\n  //   {\n  //   case MANAGE_DATA_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ManageDataResult\", {\n    switchOn: xdr.lookup(\"ManageDataResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageDataSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum BumpSequenceResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       BUMP_SEQUENCE_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       BUMP_SEQUENCE_BAD_SEQ = -1 // `bumpTo` is not within bounds\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"BumpSequenceResultCode\", {\n    bumpSequenceSuccess: 0,\n    bumpSequenceBadSeq: -1\n  }); // === xdr source ============================================================\n  //\n  //   union BumpSequenceResult switch (BumpSequenceResultCode code)\n  //   {\n  //   case BUMP_SEQUENCE_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"BumpSequenceResult\", {\n    switchOn: xdr.lookup(\"BumpSequenceResultCode\"),\n    switchName: \"code\",\n    switches: [[\"bumpSequenceSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum OperationResultCode\n  //   {\n  //       opINNER = 0, // inner object result is valid\n  //   \n  //       opBAD_AUTH = -1,     // too few valid signatures / wrong network\n  //       opNO_ACCOUNT = -2,   // source account was not found\n  //       opNOT_SUPPORTED = -3, // operation not supported at this time\n  //       opTOO_MANY_SUBENTRIES = -4, // max number of subentries already reached\n  //       opEXCEEDED_WORK_LIMIT = -5  // operation did too much work\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"OperationResultCode\", {\n    opInner: 0,\n    opBadAuth: -1,\n    opNoAccount: -2,\n    opNotSupported: -3,\n    opTooManySubentry: -4,\n    opExceededWorkLimit: -5\n  }); // === xdr source ============================================================\n  //\n  //   union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountResult createAccountResult;\n  //       case PAYMENT:\n  //           PaymentResult paymentResult;\n  //       case PATH_PAYMENT:\n  //           PathPaymentResult pathPaymentResult;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferResult manageSellOfferResult;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           ManageSellOfferResult createPassiveSellOfferResult;\n  //       case SET_OPTIONS:\n  //           SetOptionsResult setOptionsResult;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustResult changeTrustResult;\n  //       case ALLOW_TRUST:\n  //           AllowTrustResult allowTrustResult;\n  //       case ACCOUNT_MERGE:\n  //           AccountMergeResult accountMergeResult;\n  //       case INFLATION:\n  //           InflationResult inflationResult;\n  //       case MANAGE_DATA:\n  //           ManageDataResult manageDataResult;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceResult bumpSeqResult;\n  //       case MANAGE_BUY_OFFER:\n  //   \tManageBuyOfferResult manageBuyOfferResult;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"OperationResultTr\", {\n    switchOn: xdr.lookup(\"OperationType\"),\n    switchName: \"type\",\n    switches: [[\"createAccount\", \"createAccountResult\"], [\"payment\", \"paymentResult\"], [\"pathPayment\", \"pathPaymentResult\"], [\"manageSellOffer\", \"manageSellOfferResult\"], [\"createPassiveSellOffer\", \"createPassiveSellOfferResult\"], [\"setOption\", \"setOptionsResult\"], [\"changeTrust\", \"changeTrustResult\"], [\"allowTrust\", \"allowTrustResult\"], [\"accountMerge\", \"accountMergeResult\"], [\"inflation\", \"inflationResult\"], [\"manageDatum\", \"manageDataResult\"], [\"bumpSequence\", \"bumpSeqResult\"], [\"manageBuyOffer\", \"manageBuyOfferResult\"]],\n    arms: {\n      createAccountResult: xdr.lookup(\"CreateAccountResult\"),\n      paymentResult: xdr.lookup(\"PaymentResult\"),\n      pathPaymentResult: xdr.lookup(\"PathPaymentResult\"),\n      manageSellOfferResult: xdr.lookup(\"ManageSellOfferResult\"),\n      createPassiveSellOfferResult: xdr.lookup(\"ManageSellOfferResult\"),\n      setOptionsResult: xdr.lookup(\"SetOptionsResult\"),\n      changeTrustResult: xdr.lookup(\"ChangeTrustResult\"),\n      allowTrustResult: xdr.lookup(\"AllowTrustResult\"),\n      accountMergeResult: xdr.lookup(\"AccountMergeResult\"),\n      inflationResult: xdr.lookup(\"InflationResult\"),\n      manageDataResult: xdr.lookup(\"ManageDataResult\"),\n      bumpSeqResult: xdr.lookup(\"BumpSequenceResult\"),\n      manageBuyOfferResult: xdr.lookup(\"ManageBuyOfferResult\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union OperationResult switch (OperationResultCode code)\n  //   {\n  //   case opINNER:\n  //       union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountResult createAccountResult;\n  //       case PAYMENT:\n  //           PaymentResult paymentResult;\n  //       case PATH_PAYMENT:\n  //           PathPaymentResult pathPaymentResult;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferResult manageSellOfferResult;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           ManageSellOfferResult createPassiveSellOfferResult;\n  //       case SET_OPTIONS:\n  //           SetOptionsResult setOptionsResult;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustResult changeTrustResult;\n  //       case ALLOW_TRUST:\n  //           AllowTrustResult allowTrustResult;\n  //       case ACCOUNT_MERGE:\n  //           AccountMergeResult accountMergeResult;\n  //       case INFLATION:\n  //           InflationResult inflationResult;\n  //       case MANAGE_DATA:\n  //           ManageDataResult manageDataResult;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceResult bumpSeqResult;\n  //       case MANAGE_BUY_OFFER:\n  //   \tManageBuyOfferResult manageBuyOfferResult;\n  //       }\n  //       tr;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"OperationResult\", {\n    switchOn: xdr.lookup(\"OperationResultCode\"),\n    switchName: \"code\",\n    switches: [[\"opInner\", \"tr\"]],\n    arms: {\n      tr: xdr.lookup(\"OperationResultTr\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum TransactionResultCode\n  //   {\n  //       txSUCCESS = 0, // all operations succeeded\n  //   \n  //       txFAILED = -1, // one of the operations failed (none were applied)\n  //   \n  //       txTOO_EARLY = -2,         // ledger closeTime before minTime\n  //       txTOO_LATE = -3,          // ledger closeTime after maxTime\n  //       txMISSING_OPERATION = -4, // no operation was specified\n  //       txBAD_SEQ = -5,           // sequence number does not match source account\n  //   \n  //       txBAD_AUTH = -6,             // too few valid signatures / wrong network\n  //       txINSUFFICIENT_BALANCE = -7, // fee would bring account below reserve\n  //       txNO_ACCOUNT = -8,           // source account not found\n  //       txINSUFFICIENT_FEE = -9,     // fee is too small\n  //       txBAD_AUTH_EXTRA = -10,      // unused signatures attached to transaction\n  //       txINTERNAL_ERROR = -11       // an unknown error occured\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"TransactionResultCode\", {\n    txSuccess: 0,\n    txFailed: -1,\n    txTooEarly: -2,\n    txTooLate: -3,\n    txMissingOperation: -4,\n    txBadSeq: -5,\n    txBadAuth: -6,\n    txInsufficientBalance: -7,\n    txNoAccount: -8,\n    txInsufficientFee: -9,\n    txBadAuthExtra: -10,\n    txInternalError: -11\n  }); // === xdr source ============================================================\n  //\n  //   union switch (TransactionResultCode code)\n  //       {\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       default:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionResultResult\", {\n    switchOn: xdr.lookup(\"TransactionResultCode\"),\n    switchName: \"code\",\n    switches: [[\"txSuccess\", \"results\"], [\"txFailed\", \"results\"]],\n    arms: {\n      results: xdr.varArray(xdr.lookup(\"OperationResult\"), 2147483647)\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionResultExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionResult\n  //   {\n  //       int64 feeCharged; // actual fee charged for the transaction\n  //   \n  //       union switch (TransactionResultCode code)\n  //       {\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       default:\n  //           void;\n  //       }\n  //       result;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionResult\", [[\"feeCharged\", xdr.lookup(\"Int64\")], [\"result\", xdr.lookup(\"TransactionResultResult\")], [\"ext\", xdr.lookup(\"TransactionResultExt\")]]); // === xdr source ============================================================\n  //\n  //   typedef opaque Hash[32];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Hash\", xdr.opaque(32)); // === xdr source ============================================================\n  //\n  //   typedef opaque uint256[32];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Uint256\", xdr.opaque(32)); // === xdr source ============================================================\n  //\n  //   typedef unsigned int uint32;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Uint32\", xdr.uint()); // === xdr source ============================================================\n  //\n  //   typedef int int32;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Int32\", xdr.int()); // === xdr source ============================================================\n  //\n  //   typedef unsigned hyper uint64;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Uint64\", xdr.uhyper()); // === xdr source ============================================================\n  //\n  //   typedef hyper int64;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Int64\", xdr.hyper()); // === xdr source ============================================================\n  //\n  //   enum CryptoKeyType\n  //   {\n  //       KEY_TYPE_ED25519 = 0,\n  //       KEY_TYPE_PRE_AUTH_TX = 1,\n  //       KEY_TYPE_HASH_X = 2\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"CryptoKeyType\", {\n    keyTypeEd25519: 0,\n    keyTypePreAuthTx: 1,\n    keyTypeHashX: 2\n  }); // === xdr source ============================================================\n  //\n  //   enum PublicKeyType\n  //   {\n  //       PUBLIC_KEY_TYPE_ED25519 = KEY_TYPE_ED25519\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"PublicKeyType\", {\n    publicKeyTypeEd25519: 0\n  }); // === xdr source ============================================================\n  //\n  //   enum SignerKeyType\n  //   {\n  //       SIGNER_KEY_TYPE_ED25519 = KEY_TYPE_ED25519,\n  //       SIGNER_KEY_TYPE_PRE_AUTH_TX = KEY_TYPE_PRE_AUTH_TX,\n  //       SIGNER_KEY_TYPE_HASH_X = KEY_TYPE_HASH_X\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"SignerKeyType\", {\n    signerKeyTypeEd25519: 0,\n    signerKeyTypePreAuthTx: 1,\n    signerKeyTypeHashX: 2\n  }); // === xdr source ============================================================\n  //\n  //   union PublicKey switch (PublicKeyType type)\n  //   {\n  //   case PUBLIC_KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"PublicKey\", {\n    switchOn: xdr.lookup(\"PublicKeyType\"),\n    switchName: \"type\",\n    switches: [[\"publicKeyTypeEd25519\", \"ed25519\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union SignerKey switch (SignerKeyType type)\n  //   {\n  //   case SIGNER_KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   case SIGNER_KEY_TYPE_PRE_AUTH_TX:\n  //       /* SHA-256 Hash of TransactionSignaturePayload structure */\n  //       uint256 preAuthTx;\n  //   case SIGNER_KEY_TYPE_HASH_X:\n  //       /* Hash of random 256 bit preimage X */\n  //       uint256 hashX;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"SignerKey\", {\n    switchOn: xdr.lookup(\"SignerKeyType\"),\n    switchName: \"type\",\n    switches: [[\"signerKeyTypeEd25519\", \"ed25519\"], [\"signerKeyTypePreAuthTx\", \"preAuthTx\"], [\"signerKeyTypeHashX\", \"hashX\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\"),\n      preAuthTx: xdr.lookup(\"Uint256\"),\n      hashX: xdr.lookup(\"Uint256\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   typedef opaque Signature<64>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Signature\", xdr.varOpaque(64)); // === xdr source ============================================================\n  //\n  //   typedef opaque SignatureHint[4];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"SignatureHint\", xdr.opaque(4)); // === xdr source ============================================================\n  //\n  //   typedef PublicKey NodeID;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"NodeId\", xdr.lookup(\"PublicKey\")); // === xdr source ============================================================\n  //\n  //   struct Curve25519Secret\n  //   {\n  //           opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Curve25519Secret\", [[\"key\", xdr.opaque(32)]]); // === xdr source ============================================================\n  //\n  //   struct Curve25519Public\n  //   {\n  //           opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Curve25519Public\", [[\"key\", xdr.opaque(32)]]); // === xdr source ============================================================\n  //\n  //   struct HmacSha256Key\n  //   {\n  //           opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"HmacSha256Key\", [[\"key\", xdr.opaque(32)]]); // === xdr source ============================================================\n  //\n  //   struct HmacSha256Mac\n  //   {\n  //           opaque mac[32];\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"HmacSha256Mac\", [[\"mac\", xdr.opaque(32)]]);\n}); // Automatically generated on 2019-04-30T12:43:38-07:00\n// DO NOT EDIT or your changes may be overwritten\n\n/* jshint maxstatements:2147483647  */\n\n/* jshint esnext:true  */\n\nexports.default = types;","map":{"version":3,"sources":["/home/azureuser/foregin-transfers-with-stellar/infrastructure/pageB/node_modules/stellar-base/lib/generated/stellar-xdr_generated.js"],"names":["Object","defineProperty","exports","value","_jsXdr","require","XDR","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","types","config","xdr","typedef","lookup","opaque","string","varOpaque","enum","assetTypeNative","assetTypeCreditAlphanum4","assetTypeCreditAlphanum12","struct","union","switchOn","switchName","switches","void","arms","alphaNum4","alphaNum12","thresholdMasterWeight","thresholdLow","thresholdMed","thresholdHigh","account","trustline","offer","datum","authRequiredFlag","authRevocableFlag","authImmutableFlag","const","int","v1","option","varArray","authorizedFlag","passiveFlag","trustLine","data","envelopeTypeScp","envelopeTypeTx","envelopeTypeAuth","envelopeTypeScpvalue","stellarValueBasic","stellarValueSigned","lcValueSignature","array","ledgerUpgradeVersion","ledgerUpgradeBaseFee","ledgerUpgradeMaxTxSetSize","ledgerUpgradeBaseReserve","newLedgerVersion","newBaseFee","newMaxTxSetSize","newBaseReserve","metaentry","liveentry","deadentry","initentry","liveEntry","deadEntry","metaEntry","v0","ledgerEntryCreated","ledgerEntryUpdated","ledgerEntryRemoved","ledgerEntryState","created","updated","removed","state","operations","errMisc","errDatum","errConf","errAuth","errLoad","iPv4","iPv6","ipv4","ipv6","errorMsg","auth","dontHave","getPeer","peer","getTxSet","txSet","transaction","getScpQuorumset","scpQuorumset","scpMessage","getScpState","hello","error","peers","txSetHash","qSetHash","qSet","envelope","getScpLedgerSeq","scpStPrepare","scpStConfirm","scpStExternalize","scpStNominate","prepare","confirm","externalize","nominate","createAccount","payment","pathPayment","manageSellOffer","createPassiveSellOffer","setOption","changeTrust","allowTrust","accountMerge","inflation","manageDatum","bumpSequence","manageBuyOffer","assetCode4","assetCode12","bool","createAccountOp","paymentOp","pathPaymentOp","manageSellOfferOp","createPassiveSellOfferOp","setOptionsOp","changeTrustOp","allowTrustOp","destination","manageDataOp","bumpSequenceOp","manageBuyOfferOp","memoNone","memoText","memoId","memoHash","memoReturn","text","id","hash","retHash","tx","createAccountSuccess","createAccountMalformed","createAccountUnderfunded","createAccountLowReserve","createAccountAlreadyExist","defaultArm","paymentSuccess","paymentMalformed","paymentUnderfunded","paymentSrcNoTrust","paymentSrcNotAuthorized","paymentNoDestination","paymentNoTrust","paymentNotAuthorized","paymentLineFull","paymentNoIssuer","pathPaymentSuccess","pathPaymentMalformed","pathPaymentUnderfunded","pathPaymentSrcNoTrust","pathPaymentSrcNotAuthorized","pathPaymentNoDestination","pathPaymentNoTrust","pathPaymentNotAuthorized","pathPaymentLineFull","pathPaymentNoIssuer","pathPaymentTooFewOffer","pathPaymentOfferCrossSelf","pathPaymentOverSendmax","success","noIssuer","manageSellOfferSuccess","manageSellOfferMalformed","manageSellOfferSellNoTrust","manageSellOfferBuyNoTrust","manageSellOfferSellNotAuthorized","manageSellOfferBuyNotAuthorized","manageSellOfferLineFull","manageSellOfferUnderfunded","manageSellOfferCrossSelf","manageSellOfferSellNoIssuer","manageSellOfferBuyNoIssuer","manageSellOfferNotFound","manageSellOfferLowReserve","manageOfferCreated","manageOfferUpdated","manageOfferDeleted","manageBuyOfferSuccess","manageBuyOfferMalformed","manageBuyOfferSellNoTrust","manageBuyOfferBuyNoTrust","manageBuyOfferSellNotAuthorized","manageBuyOfferBuyNotAuthorized","manageBuyOfferLineFull","manageBuyOfferUnderfunded","manageBuyOfferCrossSelf","manageBuyOfferSellNoIssuer","manageBuyOfferBuyNoIssuer","manageBuyOfferNotFound","manageBuyOfferLowReserve","setOptionsSuccess","setOptionsLowReserve","setOptionsTooManySigner","setOptionsBadFlag","setOptionsInvalidInflation","setOptionsCantChange","setOptionsUnknownFlag","setOptionsThresholdOutOfRange","setOptionsBadSigner","setOptionsInvalidHomeDomain","changeTrustSuccess","changeTrustMalformed","changeTrustNoIssuer","changeTrustInvalidLimit","changeTrustLowReserve","changeTrustSelfNotAllowed","allowTrustSuccess","allowTrustMalformed","allowTrustNoTrustLine","allowTrustTrustNotRequired","allowTrustCantRevoke","allowTrustSelfNotAllowed","accountMergeSuccess","accountMergeMalformed","accountMergeNoAccount","accountMergeImmutableSet","accountMergeHasSubEntry","accountMergeSeqnumTooFar","accountMergeDestFull","sourceAccountBalance","inflationSuccess","inflationNotTime","payouts","manageDataSuccess","manageDataNotSupportedYet","manageDataNameNotFound","manageDataLowReserve","manageDataInvalidName","bumpSequenceSuccess","bumpSequenceBadSeq","opInner","opBadAuth","opNoAccount","opNotSupported","opTooManySubentry","opExceededWorkLimit","createAccountResult","paymentResult","pathPaymentResult","manageSellOfferResult","createPassiveSellOfferResult","setOptionsResult","changeTrustResult","allowTrustResult","accountMergeResult","inflationResult","manageDataResult","bumpSeqResult","manageBuyOfferResult","tr","txSuccess","txFailed","txTooEarly","txTooLate","txMissingOperation","txBadSeq","txBadAuth","txInsufficientBalance","txNoAccount","txInsufficientFee","txBadAuthExtra","txInternalError","results","uint","uhyper","hyper","keyTypeEd25519","keyTypePreAuthTx","keyTypeHashX","publicKeyTypeEd25519","signerKeyTypeEd25519","signerKeyTypePreAuthTx","signerKeyTypeHashX","ed25519","preAuthTx","hashX"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jsXdr = require(\"js-xdr\");\n\nvar XDR = _interopRequireWildcard(_jsXdr);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar types = XDR.config(function (xdr) {\n\n  // === xdr source ============================================================\n  //\n  //   typedef PublicKey AccountID;\n  //\n  // ===========================================================================\n  xdr.typedef(\"AccountId\", xdr.lookup(\"PublicKey\"));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque Thresholds[4];\n  //\n  // ===========================================================================\n  xdr.typedef(\"Thresholds\", xdr.opaque(4));\n\n  // === xdr source ============================================================\n  //\n  //   typedef string string32<32>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"String32\", xdr.string(32));\n\n  // === xdr source ============================================================\n  //\n  //   typedef string string64<64>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"String64\", xdr.string(64));\n\n  // === xdr source ============================================================\n  //\n  //   typedef int64 SequenceNumber;\n  //\n  // ===========================================================================\n  xdr.typedef(\"SequenceNumber\", xdr.lookup(\"Int64\"));\n\n  // === xdr source ============================================================\n  //\n  //   typedef uint64 TimePoint;\n  //\n  // ===========================================================================\n  xdr.typedef(\"TimePoint\", xdr.lookup(\"Uint64\"));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque DataValue<64>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"DataValue\", xdr.varOpaque(64));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque AssetCode4[4];\n  //\n  // ===========================================================================\n  xdr.typedef(\"AssetCode4\", xdr.opaque(4));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque AssetCode12[12];\n  //\n  // ===========================================================================\n  xdr.typedef(\"AssetCode12\", xdr.opaque(12));\n\n  // === xdr source ============================================================\n  //\n  //   enum AssetType\n  //   {\n  //       ASSET_TYPE_NATIVE = 0,\n  //       ASSET_TYPE_CREDIT_ALPHANUM4 = 1,\n  //       ASSET_TYPE_CREDIT_ALPHANUM12 = 2\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"AssetType\", {\n    assetTypeNative: 0,\n    assetTypeCreditAlphanum4: 1,\n    assetTypeCreditAlphanum12: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AssetCode4 assetCode;\n  //           AccountID issuer;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"AssetAlphaNum4\", [[\"assetCode\", xdr.lookup(\"AssetCode4\")], [\"issuer\", xdr.lookup(\"AccountId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AssetCode12 assetCode;\n  //           AccountID issuer;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"AssetAlphaNum12\", [[\"assetCode\", xdr.lookup(\"AssetCode12\")], [\"issuer\", xdr.lookup(\"AccountId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union Asset switch (AssetType type)\n  //   {\n  //   case ASSET_TYPE_NATIVE: // Not credit\n  //       void;\n  //   \n  //   case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //       struct\n  //       {\n  //           AssetCode4 assetCode;\n  //           AccountID issuer;\n  //       } alphaNum4;\n  //   \n  //   case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //       struct\n  //       {\n  //           AssetCode12 assetCode;\n  //           AccountID issuer;\n  //       } alphaNum12;\n  //   \n  //       // add other asset types here in the future\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"Asset\", {\n    switchOn: xdr.lookup(\"AssetType\"),\n    switchName: \"type\",\n    switches: [[\"assetTypeNative\", xdr.void()], [\"assetTypeCreditAlphanum4\", \"alphaNum4\"], [\"assetTypeCreditAlphanum12\", \"alphaNum12\"]],\n    arms: {\n      alphaNum4: xdr.lookup(\"AssetAlphaNum4\"),\n      alphaNum12: xdr.lookup(\"AssetAlphaNum12\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Price\n  //   {\n  //       int32 n; // numerator\n  //       int32 d; // denominator\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Price\", [[\"n\", xdr.lookup(\"Int32\")], [\"d\", xdr.lookup(\"Int32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct Liabilities\n  //   {\n  //       int64 buying;\n  //       int64 selling;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Liabilities\", [[\"buying\", xdr.lookup(\"Int64\")], [\"selling\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum ThresholdIndexes\n  //   {\n  //       THRESHOLD_MASTER_WEIGHT = 0,\n  //       THRESHOLD_LOW = 1,\n  //       THRESHOLD_MED = 2,\n  //       THRESHOLD_HIGH = 3\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ThresholdIndices\", {\n    thresholdMasterWeight: 0,\n    thresholdLow: 1,\n    thresholdMed: 2,\n    thresholdHigh: 3\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum LedgerEntryType\n  //   {\n  //       ACCOUNT = 0,\n  //       TRUSTLINE = 1,\n  //       OFFER = 2,\n  //       DATA = 3\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"LedgerEntryType\", {\n    account: 0,\n    trustline: 1,\n    offer: 2,\n    datum: 3\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Signer\n  //   {\n  //       SignerKey key;\n  //       uint32 weight; // really only need 1 byte\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Signer\", [[\"key\", xdr.lookup(\"SignerKey\")], [\"weight\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum AccountFlags\n  //   { // masks for each flag\n  //   \n  //       // Flags set on issuer accounts\n  //       // TrustLines are created with authorized set to \"false\" requiring\n  //       // the issuer to set it for each TrustLine\n  //       AUTH_REQUIRED_FLAG = 0x1,\n  //       // If set, the authorized flag in TrustLines can be cleared\n  //       // otherwise, authorization cannot be revoked\n  //       AUTH_REVOCABLE_FLAG = 0x2,\n  //       // Once set, causes all AUTH_* flags to be read-only\n  //       AUTH_IMMUTABLE_FLAG = 0x4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"AccountFlags\", {\n    authRequiredFlag: 1,\n    authRevocableFlag: 2,\n    authImmutableFlag: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   const MASK_ACCOUNT_FLAGS = 0x7;\n  //\n  // ===========================================================================\n  xdr.const(\"MASK_ACCOUNT_FLAGS\", 0x7);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //\n  // ===========================================================================\n  xdr.union(\"AccountEntryV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"AccountEntryV1\", [[\"liabilities\", xdr.lookup(\"Liabilities\")], [\"ext\", xdr.lookup(\"AccountEntryV1Ext\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"AccountEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"AccountEntryV1\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct AccountEntry\n  //   {\n  //       AccountID accountID;      // master public key for this account\n  //       int64 balance;            // in stroops\n  //       SequenceNumber seqNum;    // last sequence number used for this account\n  //       uint32 numSubEntries;     // number of sub-entries this account has\n  //                                 // drives the reserve\n  //       AccountID* inflationDest; // Account to vote for during inflation\n  //       uint32 flags;             // see AccountFlags\n  //   \n  //       string32 homeDomain; // can be used for reverse federation and memo lookup\n  //   \n  //       // fields used for signatures\n  //       // thresholds stores unsigned bytes: [weight of master|low|medium|high]\n  //       Thresholds thresholds;\n  //   \n  //       Signer signers<20>; // possible signers for this account\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"AccountEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"balance\", xdr.lookup(\"Int64\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"numSubEntries\", xdr.lookup(\"Uint32\")], [\"inflationDest\", xdr.option(xdr.lookup(\"AccountId\"))], [\"flags\", xdr.lookup(\"Uint32\")], [\"homeDomain\", xdr.lookup(\"String32\")], [\"thresholds\", xdr.lookup(\"Thresholds\")], [\"signers\", xdr.varArray(xdr.lookup(\"Signer\"), 20)], [\"ext\", xdr.lookup(\"AccountEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum TrustLineFlags\n  //   {\n  //       // issuer has authorized account to perform transactions with its credit\n  //       AUTHORIZED_FLAG = 1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"TrustLineFlags\", {\n    authorizedFlag: 1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   const MASK_TRUSTLINE_FLAGS = 1;\n  //\n  // ===========================================================================\n  xdr.const(\"MASK_TRUSTLINE_FLAGS\", 1);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //\n  // ===========================================================================\n  xdr.union(\"TrustLineEntryV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"TrustLineEntryV1\", [[\"liabilities\", xdr.lookup(\"Liabilities\")], [\"ext\", xdr.lookup(\"TrustLineEntryV1Ext\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TrustLineEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"TrustLineEntryV1\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TrustLineEntry\n  //   {\n  //       AccountID accountID; // account this trustline belongs to\n  //       Asset asset;         // type of asset (with issuer)\n  //       int64 balance;       // how much of this asset the user has.\n  //                            // Asset defines the unit for this;\n  //   \n  //       int64 limit;  // balance cannot be above this\n  //       uint32 flags; // see TrustLineFlags\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TrustLineEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"balance\", xdr.lookup(\"Int64\")], [\"limit\", xdr.lookup(\"Int64\")], [\"flags\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"TrustLineEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum OfferEntryFlags\n  //   {\n  //       // issuer has authorized account to perform transactions with its credit\n  //       PASSIVE_FLAG = 1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"OfferEntryFlags\", {\n    passiveFlag: 1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   const MASK_OFFERENTRY_FLAGS = 1;\n  //\n  // ===========================================================================\n  xdr.const(\"MASK_OFFERENTRY_FLAGS\", 1);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"OfferEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct OfferEntry\n  //   {\n  //       AccountID sellerID;\n  //       int64 offerID;\n  //       Asset selling; // A\n  //       Asset buying;  // B\n  //       int64 amount;  // amount of A\n  //   \n  //       /* price for this offer:\n  //           price of A in terms of B\n  //           price=AmountB/AmountA=priceNumerator/priceDenominator\n  //           price is after fees\n  //       */\n  //       Price price;\n  //       uint32 flags; // see OfferEntryFlags\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"OfferEntry\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")], [\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"flags\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"OfferEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"DataEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct DataEntry\n  //   {\n  //       AccountID accountID; // account this data belongs to\n  //       string64 dataName;\n  //       DataValue dataValue;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"DataEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"dataName\", xdr.lookup(\"String64\")], [\"dataValue\", xdr.lookup(\"DataValue\")], [\"ext\", xdr.lookup(\"DataEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (LedgerEntryType type)\n  //       {\n  //       case ACCOUNT:\n  //           AccountEntry account;\n  //       case TRUSTLINE:\n  //           TrustLineEntry trustLine;\n  //       case OFFER:\n  //           OfferEntry offer;\n  //       case DATA:\n  //           DataEntry data;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerEntryData\", {\n    switchOn: xdr.lookup(\"LedgerEntryType\"),\n    switchName: \"type\",\n    switches: [[\"account\", \"account\"], [\"trustline\", \"trustLine\"], [\"offer\", \"offer\"], [\"datum\", \"data\"]],\n    arms: {\n      account: xdr.lookup(\"AccountEntry\"),\n      trustLine: xdr.lookup(\"TrustLineEntry\"),\n      offer: xdr.lookup(\"OfferEntry\"),\n      data: xdr.lookup(\"DataEntry\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerEntry\n  //   {\n  //       uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed\n  //   \n  //       union switch (LedgerEntryType type)\n  //       {\n  //       case ACCOUNT:\n  //           AccountEntry account;\n  //       case TRUSTLINE:\n  //           TrustLineEntry trustLine;\n  //       case OFFER:\n  //           OfferEntry offer;\n  //       case DATA:\n  //           DataEntry data;\n  //       }\n  //       data;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerEntry\", [[\"lastModifiedLedgerSeq\", xdr.lookup(\"Uint32\")], [\"data\", xdr.lookup(\"LedgerEntryData\")], [\"ext\", xdr.lookup(\"LedgerEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum EnvelopeType\n  //   {\n  //       ENVELOPE_TYPE_SCP = 1,\n  //       ENVELOPE_TYPE_TX = 2,\n  //       ENVELOPE_TYPE_AUTH = 3,\n  //       ENVELOPE_TYPE_SCPVALUE = 4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"EnvelopeType\", {\n    envelopeTypeScp: 1,\n    envelopeTypeTx: 2,\n    envelopeTypeAuth: 3,\n    envelopeTypeScpvalue: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque UpgradeType<128>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"UpgradeType\", xdr.varOpaque(128));\n\n  // === xdr source ============================================================\n  //\n  //   enum StellarValueType\n  //   {\n  //       STELLAR_VALUE_BASIC = 0,\n  //       STELLAR_VALUE_SIGNED = 1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"StellarValueType\", {\n    stellarValueBasic: 0,\n    stellarValueSigned: 1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerCloseValueSignature\n  //   {\n  //       NodeID nodeID;       // which node introduced the value\n  //       Signature signature; // nodeID's signature\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerCloseValueSignature\", [[\"nodeId\", xdr.lookup(\"NodeId\")], [\"signature\", xdr.lookup(\"Signature\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (StellarValueType v)\n  //       {\n  //       case STELLAR_VALUE_BASIC:\n  //           void;\n  //       case STELLAR_VALUE_SIGNED:\n  //           LedgerCloseValueSignature lcValueSignature;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"StellarValueExt\", {\n    switchOn: xdr.lookup(\"StellarValueType\"),\n    switchName: \"v\",\n    switches: [[\"stellarValueBasic\", xdr.void()], [\"stellarValueSigned\", \"lcValueSignature\"]],\n    arms: {\n      lcValueSignature: xdr.lookup(\"LedgerCloseValueSignature\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct StellarValue\n  //   {\n  //       Hash txSetHash;      // transaction set to apply to previous ledger\n  //       TimePoint closeTime; // network close time\n  //   \n  //       // upgrades to apply to the previous ledger (usually empty)\n  //       // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop\n  //       // unknown steps during consensus if needed.\n  //       // see notes below on 'LedgerUpgrade' for more detail\n  //       // max size is dictated by number of upgrade types (+ room for future)\n  //       UpgradeType upgrades<6>;\n  //   \n  //       // reserved for future use\n  //       union switch (StellarValueType v)\n  //       {\n  //       case STELLAR_VALUE_BASIC:\n  //           void;\n  //       case STELLAR_VALUE_SIGNED:\n  //           LedgerCloseValueSignature lcValueSignature;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"StellarValue\", [[\"txSetHash\", xdr.lookup(\"Hash\")], [\"closeTime\", xdr.lookup(\"TimePoint\")], [\"upgrades\", xdr.varArray(xdr.lookup(\"UpgradeType\"), 6)], [\"ext\", xdr.lookup(\"StellarValueExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerHeaderExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerHeader\n  //   {\n  //       uint32 ledgerVersion;    // the protocol version of the ledger\n  //       Hash previousLedgerHash; // hash of the previous ledger header\n  //       StellarValue scpValue;   // what consensus agreed to\n  //       Hash txSetResultHash;    // the TransactionResultSet that led to this ledger\n  //       Hash bucketListHash;     // hash of the ledger state\n  //   \n  //       uint32 ledgerSeq; // sequence number of this ledger\n  //   \n  //       int64 totalCoins; // total number of stroops in existence.\n  //                         // 10,000,000 stroops in 1 XLM\n  //   \n  //       int64 feePool;       // fees burned since last inflation run\n  //       uint32 inflationSeq; // inflation sequence number\n  //   \n  //       uint64 idPool; // last used global ID, used for generating objects\n  //   \n  //       uint32 baseFee;     // base fee per operation in stroops\n  //       uint32 baseReserve; // account base reserve in stroops\n  //   \n  //       uint32 maxTxSetSize; // maximum size a transaction set can be\n  //   \n  //       Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back\n  //                         // in time without walking the chain back ledger by ledger\n  //                         // each slot contains the oldest ledger that is mod of\n  //                         // either 50  5000  50000 or 500000 depending on index\n  //                         // skipList[0] mod(50), skipList[1] mod(5000), etc\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerHeader\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"previousLedgerHash\", xdr.lookup(\"Hash\")], [\"scpValue\", xdr.lookup(\"StellarValue\")], [\"txSetResultHash\", xdr.lookup(\"Hash\")], [\"bucketListHash\", xdr.lookup(\"Hash\")], [\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"totalCoins\", xdr.lookup(\"Int64\")], [\"feePool\", xdr.lookup(\"Int64\")], [\"inflationSeq\", xdr.lookup(\"Uint32\")], [\"idPool\", xdr.lookup(\"Uint64\")], [\"baseFee\", xdr.lookup(\"Uint32\")], [\"baseReserve\", xdr.lookup(\"Uint32\")], [\"maxTxSetSize\", xdr.lookup(\"Uint32\")], [\"skipList\", xdr.array(xdr.lookup(\"Hash\"), 4)], [\"ext\", xdr.lookup(\"LedgerHeaderExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum LedgerUpgradeType\n  //   {\n  //       LEDGER_UPGRADE_VERSION = 1,\n  //       LEDGER_UPGRADE_BASE_FEE = 2,\n  //       LEDGER_UPGRADE_MAX_TX_SET_SIZE = 3,\n  //       LEDGER_UPGRADE_BASE_RESERVE = 4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"LedgerUpgradeType\", {\n    ledgerUpgradeVersion: 1,\n    ledgerUpgradeBaseFee: 2,\n    ledgerUpgradeMaxTxSetSize: 3,\n    ledgerUpgradeBaseReserve: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union LedgerUpgrade switch (LedgerUpgradeType type)\n  //   {\n  //   case LEDGER_UPGRADE_VERSION:\n  //       uint32 newLedgerVersion; // update ledgerVersion\n  //   case LEDGER_UPGRADE_BASE_FEE:\n  //       uint32 newBaseFee; // update baseFee\n  //   case LEDGER_UPGRADE_MAX_TX_SET_SIZE:\n  //       uint32 newMaxTxSetSize; // update maxTxSetSize\n  //   case LEDGER_UPGRADE_BASE_RESERVE:\n  //       uint32 newBaseReserve; // update baseReserve\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerUpgrade\", {\n    switchOn: xdr.lookup(\"LedgerUpgradeType\"),\n    switchName: \"type\",\n    switches: [[\"ledgerUpgradeVersion\", \"newLedgerVersion\"], [\"ledgerUpgradeBaseFee\", \"newBaseFee\"], [\"ledgerUpgradeMaxTxSetSize\", \"newMaxTxSetSize\"], [\"ledgerUpgradeBaseReserve\", \"newBaseReserve\"]],\n    arms: {\n      newLedgerVersion: xdr.lookup(\"Uint32\"),\n      newBaseFee: xdr.lookup(\"Uint32\"),\n      newMaxTxSetSize: xdr.lookup(\"Uint32\"),\n      newBaseReserve: xdr.lookup(\"Uint32\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyAccount\", [[\"accountId\", xdr.lookup(\"AccountId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           Asset asset;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyTrustLine\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID sellerID;\n  //           int64 offerID;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyOffer\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           string64 dataName;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyData\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"dataName\", xdr.lookup(\"String64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union LedgerKey switch (LedgerEntryType type)\n  //   {\n  //   case ACCOUNT:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //       } account;\n  //   \n  //   case TRUSTLINE:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           Asset asset;\n  //       } trustLine;\n  //   \n  //   case OFFER:\n  //       struct\n  //       {\n  //           AccountID sellerID;\n  //           int64 offerID;\n  //       } offer;\n  //   \n  //   case DATA:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           string64 dataName;\n  //       } data;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerKey\", {\n    switchOn: xdr.lookup(\"LedgerEntryType\"),\n    switchName: \"type\",\n    switches: [[\"account\", \"account\"], [\"trustline\", \"trustLine\"], [\"offer\", \"offer\"], [\"datum\", \"data\"]],\n    arms: {\n      account: xdr.lookup(\"LedgerKeyAccount\"),\n      trustLine: xdr.lookup(\"LedgerKeyTrustLine\"),\n      offer: xdr.lookup(\"LedgerKeyOffer\"),\n      data: xdr.lookup(\"LedgerKeyData\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum BucketEntryType\n  //   {\n  //       METAENTRY =\n  //           -1, // At-and-after protocol 11: bucket metadata, should come first.\n  //       LIVEENTRY = 0, // Before protocol 11: created-or-updated;\n  //                      // At-and-after protocol 11: only updated.\n  //       DEADENTRY = 1,\n  //       INITENTRY = 2 // At-and-after protocol 11: only created.\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"BucketEntryType\", {\n    metaentry: -1,\n    liveentry: 0,\n    deadentry: 1,\n    initentry: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"BucketMetadataExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct BucketMetadata\n  //   {\n  //       // Indicates the protocol version used to create / merge this bucket.\n  //       uint32 ledgerVersion;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"BucketMetadata\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"BucketMetadataExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union BucketEntry switch (BucketEntryType type)\n  //   {\n  //   case LIVEENTRY:\n  //   case INITENTRY:\n  //       LedgerEntry liveEntry;\n  //   \n  //   case DEADENTRY:\n  //       LedgerKey deadEntry;\n  //   case METAENTRY:\n  //       BucketMetadata metaEntry;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"BucketEntry\", {\n    switchOn: xdr.lookup(\"BucketEntryType\"),\n    switchName: \"type\",\n    switches: [[\"liveentry\", \"liveEntry\"], [\"initentry\", \"liveEntry\"], [\"deadentry\", \"deadEntry\"], [\"metaentry\", \"metaEntry\"]],\n    arms: {\n      liveEntry: xdr.lookup(\"LedgerEntry\"),\n      deadEntry: xdr.lookup(\"LedgerKey\"),\n      metaEntry: xdr.lookup(\"BucketMetadata\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionSet\n  //   {\n  //       Hash previousLedgerHash;\n  //       TransactionEnvelope txs<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionSet\", [[\"previousLedgerHash\", xdr.lookup(\"Hash\")], [\"txes\", xdr.varArray(xdr.lookup(\"TransactionEnvelope\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionResultPair\n  //   {\n  //       Hash transactionHash;\n  //       TransactionResult result; // result for the transaction\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionResultPair\", [[\"transactionHash\", xdr.lookup(\"Hash\")], [\"result\", xdr.lookup(\"TransactionResult\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionResultSet\n  //   {\n  //       TransactionResultPair results<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionResultSet\", [[\"results\", xdr.varArray(xdr.lookup(\"TransactionResultPair\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionHistoryEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionHistoryEntry\n  //   {\n  //       uint32 ledgerSeq;\n  //       TransactionSet txSet;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionHistoryEntry\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"txSet\", xdr.lookup(\"TransactionSet\")], [\"ext\", xdr.lookup(\"TransactionHistoryEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionHistoryResultEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionHistoryResultEntry\n  //   {\n  //       uint32 ledgerSeq;\n  //       TransactionResultSet txResultSet;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionHistoryResultEntry\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"txResultSet\", xdr.lookup(\"TransactionResultSet\")], [\"ext\", xdr.lookup(\"TransactionHistoryResultEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerHeaderHistoryEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerHeaderHistoryEntry\n  //   {\n  //       Hash hash;\n  //       LedgerHeader header;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerHeaderHistoryEntry\", [[\"hash\", xdr.lookup(\"Hash\")], [\"header\", xdr.lookup(\"LedgerHeader\")], [\"ext\", xdr.lookup(\"LedgerHeaderHistoryEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerSCPMessages\n  //   {\n  //       uint32 ledgerSeq;\n  //       SCPEnvelope messages<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerScpMessages\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"messages\", xdr.varArray(xdr.lookup(\"ScpEnvelope\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPHistoryEntryV0\n  //   {\n  //       SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages\n  //       LedgerSCPMessages ledgerMessages;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpHistoryEntryV0\", [[\"quorumSets\", xdr.varArray(xdr.lookup(\"ScpQuorumSet\"), 2147483647)], [\"ledgerMessages\", xdr.lookup(\"LedgerScpMessages\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union SCPHistoryEntry switch (int v)\n  //   {\n  //   case 0:\n  //       SCPHistoryEntryV0 v0;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ScpHistoryEntry\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"ScpHistoryEntryV0\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum LedgerEntryChangeType\n  //   {\n  //       LEDGER_ENTRY_CREATED = 0, // entry was added to the ledger\n  //       LEDGER_ENTRY_UPDATED = 1, // entry was modified in the ledger\n  //       LEDGER_ENTRY_REMOVED = 2, // entry was removed from the ledger\n  //       LEDGER_ENTRY_STATE = 3    // value of the entry\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"LedgerEntryChangeType\", {\n    ledgerEntryCreated: 0,\n    ledgerEntryUpdated: 1,\n    ledgerEntryRemoved: 2,\n    ledgerEntryState: 3\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union LedgerEntryChange switch (LedgerEntryChangeType type)\n  //   {\n  //   case LEDGER_ENTRY_CREATED:\n  //       LedgerEntry created;\n  //   case LEDGER_ENTRY_UPDATED:\n  //       LedgerEntry updated;\n  //   case LEDGER_ENTRY_REMOVED:\n  //       LedgerKey removed;\n  //   case LEDGER_ENTRY_STATE:\n  //       LedgerEntry state;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerEntryChange\", {\n    switchOn: xdr.lookup(\"LedgerEntryChangeType\"),\n    switchName: \"type\",\n    switches: [[\"ledgerEntryCreated\", \"created\"], [\"ledgerEntryUpdated\", \"updated\"], [\"ledgerEntryRemoved\", \"removed\"], [\"ledgerEntryState\", \"state\"]],\n    arms: {\n      created: xdr.lookup(\"LedgerEntry\"),\n      updated: xdr.lookup(\"LedgerEntry\"),\n      removed: xdr.lookup(\"LedgerKey\"),\n      state: xdr.lookup(\"LedgerEntry\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   typedef LedgerEntryChange LedgerEntryChanges<>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"LedgerEntryChanges\", xdr.varArray(xdr.lookup(\"LedgerEntryChange\"), 2147483647));\n\n  // === xdr source ============================================================\n  //\n  //   struct OperationMeta\n  //   {\n  //       LedgerEntryChanges changes;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"OperationMeta\", [[\"changes\", xdr.lookup(\"LedgerEntryChanges\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionMetaV1\n  //   {\n  //       LedgerEntryChanges txChanges; // tx level changes if any\n  //       OperationMeta operations<>;   // meta for each operation\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionMetaV1\", [[\"txChanges\", xdr.lookup(\"LedgerEntryChanges\")], [\"operations\", xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   union TransactionMeta switch (int v)\n  //   {\n  //   case 0:\n  //       OperationMeta operations<>;\n  //   case 1:\n  //       TransactionMetaV1 v1;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionMeta\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"operations\"], [1, \"v1\"]],\n    arms: {\n      operations: xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647),\n      v1: xdr.lookup(\"TransactionMetaV1\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ErrorCode\n  //   {\n  //       ERR_MISC = 0, // Unspecific error\n  //       ERR_DATA = 1, // Malformed data\n  //       ERR_CONF = 2, // Misconfiguration error\n  //       ERR_AUTH = 3, // Authentication failure\n  //       ERR_LOAD = 4  // System overloaded\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ErrorCode\", {\n    errMisc: 0,\n    errDatum: 1,\n    errConf: 2,\n    errAuth: 3,\n    errLoad: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Error\n  //   {\n  //       ErrorCode code;\n  //       string msg<100>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Error\", [[\"code\", xdr.lookup(\"ErrorCode\")], [\"msg\", xdr.string(100)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct AuthCert\n  //   {\n  //       Curve25519Public pubkey;\n  //       uint64 expiration;\n  //       Signature sig;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"AuthCert\", [[\"pubkey\", xdr.lookup(\"Curve25519Public\")], [\"expiration\", xdr.lookup(\"Uint64\")], [\"sig\", xdr.lookup(\"Signature\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct Hello\n  //   {\n  //       uint32 ledgerVersion;\n  //       uint32 overlayVersion;\n  //       uint32 overlayMinVersion;\n  //       Hash networkID;\n  //       string versionStr<100>;\n  //       int listeningPort;\n  //       NodeID peerID;\n  //       AuthCert cert;\n  //       uint256 nonce;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Hello\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"overlayVersion\", xdr.lookup(\"Uint32\")], [\"overlayMinVersion\", xdr.lookup(\"Uint32\")], [\"networkId\", xdr.lookup(\"Hash\")], [\"versionStr\", xdr.string(100)], [\"listeningPort\", xdr.int()], [\"peerId\", xdr.lookup(\"NodeId\")], [\"cert\", xdr.lookup(\"AuthCert\")], [\"nonce\", xdr.lookup(\"Uint256\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct Auth\n  //   {\n  //       // Empty message, just to confirm\n  //       // establishment of MAC keys.\n  //       int unused;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Auth\", [[\"unused\", xdr.int()]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum IPAddrType\n  //   {\n  //       IPv4 = 0,\n  //       IPv6 = 1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"IpAddrType\", {\n    iPv4: 0,\n    iPv6: 1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (IPAddrType type)\n  //       {\n  //       case IPv4:\n  //           opaque ipv4[4];\n  //       case IPv6:\n  //           opaque ipv6[16];\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"PeerAddressIp\", {\n    switchOn: xdr.lookup(\"IpAddrType\"),\n    switchName: \"type\",\n    switches: [[\"iPv4\", \"ipv4\"], [\"iPv6\", \"ipv6\"]],\n    arms: {\n      ipv4: xdr.opaque(4),\n      ipv6: xdr.opaque(16)\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct PeerAddress\n  //   {\n  //       union switch (IPAddrType type)\n  //       {\n  //       case IPv4:\n  //           opaque ipv4[4];\n  //       case IPv6:\n  //           opaque ipv6[16];\n  //       }\n  //       ip;\n  //       uint32 port;\n  //       uint32 numFailures;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"PeerAddress\", [[\"ip\", xdr.lookup(\"PeerAddressIp\")], [\"port\", xdr.lookup(\"Uint32\")], [\"numFailures\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum MessageType\n  //   {\n  //       ERROR_MSG = 0,\n  //       AUTH = 2,\n  //       DONT_HAVE = 3,\n  //   \n  //       GET_PEERS = 4, // gets a list of peers this guy knows about\n  //       PEERS = 5,\n  //   \n  //       GET_TX_SET = 6, // gets a particular txset by hash\n  //       TX_SET = 7,\n  //   \n  //       TRANSACTION = 8, // pass on a tx you have heard about\n  //   \n  //       // SCP\n  //       GET_SCP_QUORUMSET = 9,\n  //       SCP_QUORUMSET = 10,\n  //       SCP_MESSAGE = 11,\n  //       GET_SCP_STATE = 12,\n  //   \n  //       // new messages\n  //       HELLO = 13\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"MessageType\", {\n    errorMsg: 0,\n    auth: 2,\n    dontHave: 3,\n    getPeer: 4,\n    peer: 5,\n    getTxSet: 6,\n    txSet: 7,\n    transaction: 8,\n    getScpQuorumset: 9,\n    scpQuorumset: 10,\n    scpMessage: 11,\n    getScpState: 12,\n    hello: 13\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct DontHave\n  //   {\n  //       MessageType type;\n  //       uint256 reqHash;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"DontHave\", [[\"type\", xdr.lookup(\"MessageType\")], [\"reqHash\", xdr.lookup(\"Uint256\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union StellarMessage switch (MessageType type)\n  //   {\n  //   case ERROR_MSG:\n  //       Error error;\n  //   case HELLO:\n  //       Hello hello;\n  //   case AUTH:\n  //       Auth auth;\n  //   case DONT_HAVE:\n  //       DontHave dontHave;\n  //   case GET_PEERS:\n  //       void;\n  //   case PEERS:\n  //       PeerAddress peers<100>;\n  //   \n  //   case GET_TX_SET:\n  //       uint256 txSetHash;\n  //   case TX_SET:\n  //       TransactionSet txSet;\n  //   \n  //   case TRANSACTION:\n  //       TransactionEnvelope transaction;\n  //   \n  //   // SCP\n  //   case GET_SCP_QUORUMSET:\n  //       uint256 qSetHash;\n  //   case SCP_QUORUMSET:\n  //       SCPQuorumSet qSet;\n  //   case SCP_MESSAGE:\n  //       SCPEnvelope envelope;\n  //   case GET_SCP_STATE:\n  //       uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"StellarMessage\", {\n    switchOn: xdr.lookup(\"MessageType\"),\n    switchName: \"type\",\n    switches: [[\"errorMsg\", \"error\"], [\"hello\", \"hello\"], [\"auth\", \"auth\"], [\"dontHave\", \"dontHave\"], [\"getPeer\", xdr.void()], [\"peer\", \"peers\"], [\"getTxSet\", \"txSetHash\"], [\"txSet\", \"txSet\"], [\"transaction\", \"transaction\"], [\"getScpQuorumset\", \"qSetHash\"], [\"scpQuorumset\", \"qSet\"], [\"scpMessage\", \"envelope\"], [\"getScpState\", \"getScpLedgerSeq\"]],\n    arms: {\n      error: xdr.lookup(\"Error\"),\n      hello: xdr.lookup(\"Hello\"),\n      auth: xdr.lookup(\"Auth\"),\n      dontHave: xdr.lookup(\"DontHave\"),\n      peers: xdr.varArray(xdr.lookup(\"PeerAddress\"), 100),\n      txSetHash: xdr.lookup(\"Uint256\"),\n      txSet: xdr.lookup(\"TransactionSet\"),\n      transaction: xdr.lookup(\"TransactionEnvelope\"),\n      qSetHash: xdr.lookup(\"Uint256\"),\n      qSet: xdr.lookup(\"ScpQuorumSet\"),\n      envelope: xdr.lookup(\"ScpEnvelope\"),\n      getScpLedgerSeq: xdr.lookup(\"Uint32\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //   {\n  //      uint64 sequence;\n  //      StellarMessage message;\n  //      HmacSha256Mac mac;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"AuthenticatedMessageV0\", [[\"sequence\", xdr.lookup(\"Uint64\")], [\"message\", xdr.lookup(\"StellarMessage\")], [\"mac\", xdr.lookup(\"HmacSha256Mac\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union AuthenticatedMessage switch (uint32 v)\n  //   {\n  //   case 0:\n  //       struct\n  //   {\n  //      uint64 sequence;\n  //      StellarMessage message;\n  //      HmacSha256Mac mac;\n  //       } v0;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"AuthenticatedMessage\", {\n    switchOn: xdr.lookup(\"Uint32\"),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"AuthenticatedMessageV0\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque Value<>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Value\", xdr.varOpaque());\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPBallot\n  //   {\n  //       uint32 counter; // n\n  //       Value value;    // x\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpBallot\", [[\"counter\", xdr.lookup(\"Uint32\")], [\"value\", xdr.lookup(\"Value\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum SCPStatementType\n  //   {\n  //       SCP_ST_PREPARE = 0,\n  //       SCP_ST_CONFIRM = 1,\n  //       SCP_ST_EXTERNALIZE = 2,\n  //       SCP_ST_NOMINATE = 3\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ScpStatementType\", {\n    scpStPrepare: 0,\n    scpStConfirm: 1,\n    scpStExternalize: 2,\n    scpStNominate: 3\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPNomination\n  //   {\n  //       Hash quorumSetHash; // D\n  //       Value votes<>;      // X\n  //       Value accepted<>;   // Y\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpNomination\", [[\"quorumSetHash\", xdr.lookup(\"Hash\")], [\"votes\", xdr.varArray(xdr.lookup(\"Value\"), 2147483647)], [\"accepted\", xdr.varArray(xdr.lookup(\"Value\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpStatementPrepare\", [[\"quorumSetHash\", xdr.lookup(\"Hash\")], [\"ballot\", xdr.lookup(\"ScpBallot\")], [\"prepared\", xdr.option(xdr.lookup(\"ScpBallot\"))], [\"preparedPrime\", xdr.option(xdr.lookup(\"ScpBallot\"))], [\"nC\", xdr.lookup(\"Uint32\")], [\"nH\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpStatementConfirm\", [[\"ballot\", xdr.lookup(\"ScpBallot\")], [\"nPrepared\", xdr.lookup(\"Uint32\")], [\"nCommit\", xdr.lookup(\"Uint32\")], [\"nH\", xdr.lookup(\"Uint32\")], [\"quorumSetHash\", xdr.lookup(\"Hash\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpStatementExternalize\", [[\"commit\", xdr.lookup(\"ScpBallot\")], [\"nH\", xdr.lookup(\"Uint32\")], [\"commitQuorumSetHash\", xdr.lookup(\"Hash\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (SCPStatementType type)\n  //       {\n  //       case SCP_ST_PREPARE:\n  //           struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           } prepare;\n  //       case SCP_ST_CONFIRM:\n  //           struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           } confirm;\n  //       case SCP_ST_EXTERNALIZE:\n  //           struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           } externalize;\n  //       case SCP_ST_NOMINATE:\n  //           SCPNomination nominate;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"ScpStatementPledges\", {\n    switchOn: xdr.lookup(\"ScpStatementType\"),\n    switchName: \"type\",\n    switches: [[\"scpStPrepare\", \"prepare\"], [\"scpStConfirm\", \"confirm\"], [\"scpStExternalize\", \"externalize\"], [\"scpStNominate\", \"nominate\"]],\n    arms: {\n      prepare: xdr.lookup(\"ScpStatementPrepare\"),\n      confirm: xdr.lookup(\"ScpStatementConfirm\"),\n      externalize: xdr.lookup(\"ScpStatementExternalize\"),\n      nominate: xdr.lookup(\"ScpNomination\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPStatement\n  //   {\n  //       NodeID nodeID;    // v\n  //       uint64 slotIndex; // i\n  //   \n  //       union switch (SCPStatementType type)\n  //       {\n  //       case SCP_ST_PREPARE:\n  //           struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           } prepare;\n  //       case SCP_ST_CONFIRM:\n  //           struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           } confirm;\n  //       case SCP_ST_EXTERNALIZE:\n  //           struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           } externalize;\n  //       case SCP_ST_NOMINATE:\n  //           SCPNomination nominate;\n  //       }\n  //       pledges;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpStatement\", [[\"nodeId\", xdr.lookup(\"NodeId\")], [\"slotIndex\", xdr.lookup(\"Uint64\")], [\"pledges\", xdr.lookup(\"ScpStatementPledges\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPEnvelope\n  //   {\n  //       SCPStatement statement;\n  //       Signature signature;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpEnvelope\", [[\"statement\", xdr.lookup(\"ScpStatement\")], [\"signature\", xdr.lookup(\"Signature\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPQuorumSet\n  //   {\n  //       uint32 threshold;\n  //       PublicKey validators<>;\n  //       SCPQuorumSet innerSets<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpQuorumSet\", [[\"threshold\", xdr.lookup(\"Uint32\")], [\"validators\", xdr.varArray(xdr.lookup(\"PublicKey\"), 2147483647)], [\"innerSets\", xdr.varArray(xdr.lookup(\"ScpQuorumSet\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct DecoratedSignature\n  //   {\n  //       SignatureHint hint;  // last 4 bytes of the public key, used as a hint\n  //       Signature signature; // actual signature\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"DecoratedSignature\", [[\"hint\", xdr.lookup(\"SignatureHint\")], [\"signature\", xdr.lookup(\"Signature\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum OperationType\n  //   {\n  //       CREATE_ACCOUNT = 0,\n  //       PAYMENT = 1,\n  //       PATH_PAYMENT = 2,\n  //       MANAGE_SELL_OFFER = 3,\n  //       CREATE_PASSIVE_SELL_OFFER = 4,\n  //       SET_OPTIONS = 5,\n  //       CHANGE_TRUST = 6,\n  //       ALLOW_TRUST = 7,\n  //       ACCOUNT_MERGE = 8,\n  //       INFLATION = 9,\n  //       MANAGE_DATA = 10,\n  //       BUMP_SEQUENCE = 11,\n  //       MANAGE_BUY_OFFER = 12\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"OperationType\", {\n    createAccount: 0,\n    payment: 1,\n    pathPayment: 2,\n    manageSellOffer: 3,\n    createPassiveSellOffer: 4,\n    setOption: 5,\n    changeTrust: 6,\n    allowTrust: 7,\n    accountMerge: 8,\n    inflation: 9,\n    manageDatum: 10,\n    bumpSequence: 11,\n    manageBuyOffer: 12\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct CreateAccountOp\n  //   {\n  //       AccountID destination; // account to create\n  //       int64 startingBalance; // amount they end up with\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"CreateAccountOp\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"startingBalance\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct PaymentOp\n  //   {\n  //       AccountID destination; // recipient of the payment\n  //       Asset asset;           // what they end up with\n  //       int64 amount;          // amount they end up with\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"PaymentOp\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct PathPaymentOp\n  //   {\n  //       Asset sendAsset; // asset we pay with\n  //       int64 sendMax;   // the maximum amount of sendAsset to\n  //                        // send (excluding fees).\n  //                        // The operation will fail if can't be met\n  //   \n  //       AccountID destination; // recipient of the payment\n  //       Asset destAsset;       // what they end up with\n  //       int64 destAmount;      // amount they end up with\n  //   \n  //       Asset path<5>; // additional hops it must go through to get there\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"PathPaymentOp\", [[\"sendAsset\", xdr.lookup(\"Asset\")], [\"sendMax\", xdr.lookup(\"Int64\")], [\"destination\", xdr.lookup(\"AccountId\")], [\"destAsset\", xdr.lookup(\"Asset\")], [\"destAmount\", xdr.lookup(\"Int64\")], [\"path\", xdr.varArray(xdr.lookup(\"Asset\"), 5)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ManageSellOfferOp\n  //   {\n  //       Asset selling;\n  //       Asset buying;\n  //       int64 amount; // amount being sold. if set to 0, delete the offer\n  //       Price price;  // price of thing being sold in terms of what you are buying\n  //   \n  //       // 0=create a new offer, otherwise edit an existing offer\n  //       int64 offerID;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ManageSellOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"offerId\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ManageBuyOfferOp\n  //   {\n  //       Asset selling;\n  //       Asset buying;\n  //       int64 buyAmount; // amount being bought. if set to 0, delete the offer\n  //       Price price;     // price of thing being bought in terms of what you are\n  //                        // selling\n  //   \n  //       // 0=create a new offer, otherwise edit an existing offer\n  //       int64 offerID;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ManageBuyOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"buyAmount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"offerId\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct CreatePassiveSellOfferOp\n  //   {\n  //       Asset selling; // A\n  //       Asset buying;  // B\n  //       int64 amount;  // amount taker gets. if set to 0, delete the offer\n  //       Price price;   // cost of A in terms of B\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"CreatePassiveSellOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SetOptionsOp\n  //   {\n  //       AccountID* inflationDest; // sets the inflation destination\n  //   \n  //       uint32* clearFlags; // which flags to clear\n  //       uint32* setFlags;   // which flags to set\n  //   \n  //       // account threshold manipulation\n  //       uint32* masterWeight; // weight of the master account\n  //       uint32* lowThreshold;\n  //       uint32* medThreshold;\n  //       uint32* highThreshold;\n  //   \n  //       string32* homeDomain; // sets the home domain\n  //   \n  //       // Add, update or remove a signer for the account\n  //       // signer is deleted if the weight is 0\n  //       Signer* signer;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"SetOptionsOp\", [[\"inflationDest\", xdr.option(xdr.lookup(\"AccountId\"))], [\"clearFlags\", xdr.option(xdr.lookup(\"Uint32\"))], [\"setFlags\", xdr.option(xdr.lookup(\"Uint32\"))], [\"masterWeight\", xdr.option(xdr.lookup(\"Uint32\"))], [\"lowThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"medThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"highThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"homeDomain\", xdr.option(xdr.lookup(\"String32\"))], [\"signer\", xdr.option(xdr.lookup(\"Signer\"))]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ChangeTrustOp\n  //   {\n  //       Asset line;\n  //   \n  //       // if limit is set to 0, deletes the trust line\n  //       int64 limit;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ChangeTrustOp\", [[\"line\", xdr.lookup(\"Asset\")], [\"limit\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (AssetType type)\n  //       {\n  //       // ASSET_TYPE_NATIVE is not allowed\n  //       case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //           AssetCode4 assetCode4;\n  //   \n  //       case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //           AssetCode12 assetCode12;\n  //   \n  //           // add other asset types here in the future\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"AllowTrustOpAsset\", {\n    switchOn: xdr.lookup(\"AssetType\"),\n    switchName: \"type\",\n    switches: [[\"assetTypeCreditAlphanum4\", \"assetCode4\"], [\"assetTypeCreditAlphanum12\", \"assetCode12\"]],\n    arms: {\n      assetCode4: xdr.lookup(\"AssetCode4\"),\n      assetCode12: xdr.lookup(\"AssetCode12\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct AllowTrustOp\n  //   {\n  //       AccountID trustor;\n  //       union switch (AssetType type)\n  //       {\n  //       // ASSET_TYPE_NATIVE is not allowed\n  //       case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //           AssetCode4 assetCode4;\n  //   \n  //       case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //           AssetCode12 assetCode12;\n  //   \n  //           // add other asset types here in the future\n  //       }\n  //       asset;\n  //   \n  //       bool authorize;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"AllowTrustOp\", [[\"trustor\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"AllowTrustOpAsset\")], [\"authorize\", xdr.bool()]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ManageDataOp\n  //   {\n  //       string64 dataName;\n  //       DataValue* dataValue; // set to null to clear\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ManageDataOp\", [[\"dataName\", xdr.lookup(\"String64\")], [\"dataValue\", xdr.option(xdr.lookup(\"DataValue\"))]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct BumpSequenceOp\n  //   {\n  //       SequenceNumber bumpTo;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"BumpSequenceOp\", [[\"bumpTo\", xdr.lookup(\"SequenceNumber\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountOp createAccountOp;\n  //       case PAYMENT:\n  //           PaymentOp paymentOp;\n  //       case PATH_PAYMENT:\n  //           PathPaymentOp pathPaymentOp;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferOp manageSellOfferOp;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           CreatePassiveSellOfferOp createPassiveSellOfferOp;\n  //       case SET_OPTIONS:\n  //           SetOptionsOp setOptionsOp;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustOp changeTrustOp;\n  //       case ALLOW_TRUST:\n  //           AllowTrustOp allowTrustOp;\n  //       case ACCOUNT_MERGE:\n  //           AccountID destination;\n  //       case INFLATION:\n  //           void;\n  //       case MANAGE_DATA:\n  //           ManageDataOp manageDataOp;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceOp bumpSequenceOp;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferOp manageBuyOfferOp;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"OperationBody\", {\n    switchOn: xdr.lookup(\"OperationType\"),\n    switchName: \"type\",\n    switches: [[\"createAccount\", \"createAccountOp\"], [\"payment\", \"paymentOp\"], [\"pathPayment\", \"pathPaymentOp\"], [\"manageSellOffer\", \"manageSellOfferOp\"], [\"createPassiveSellOffer\", \"createPassiveSellOfferOp\"], [\"setOption\", \"setOptionsOp\"], [\"changeTrust\", \"changeTrustOp\"], [\"allowTrust\", \"allowTrustOp\"], [\"accountMerge\", \"destination\"], [\"inflation\", xdr.void()], [\"manageDatum\", \"manageDataOp\"], [\"bumpSequence\", \"bumpSequenceOp\"], [\"manageBuyOffer\", \"manageBuyOfferOp\"]],\n    arms: {\n      createAccountOp: xdr.lookup(\"CreateAccountOp\"),\n      paymentOp: xdr.lookup(\"PaymentOp\"),\n      pathPaymentOp: xdr.lookup(\"PathPaymentOp\"),\n      manageSellOfferOp: xdr.lookup(\"ManageSellOfferOp\"),\n      createPassiveSellOfferOp: xdr.lookup(\"CreatePassiveSellOfferOp\"),\n      setOptionsOp: xdr.lookup(\"SetOptionsOp\"),\n      changeTrustOp: xdr.lookup(\"ChangeTrustOp\"),\n      allowTrustOp: xdr.lookup(\"AllowTrustOp\"),\n      destination: xdr.lookup(\"AccountId\"),\n      manageDataOp: xdr.lookup(\"ManageDataOp\"),\n      bumpSequenceOp: xdr.lookup(\"BumpSequenceOp\"),\n      manageBuyOfferOp: xdr.lookup(\"ManageBuyOfferOp\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Operation\n  //   {\n  //       // sourceAccount is the account used to run the operation\n  //       // if not set, the runtime defaults to \"sourceAccount\" specified at\n  //       // the transaction level\n  //       AccountID* sourceAccount;\n  //   \n  //       union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountOp createAccountOp;\n  //       case PAYMENT:\n  //           PaymentOp paymentOp;\n  //       case PATH_PAYMENT:\n  //           PathPaymentOp pathPaymentOp;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferOp manageSellOfferOp;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           CreatePassiveSellOfferOp createPassiveSellOfferOp;\n  //       case SET_OPTIONS:\n  //           SetOptionsOp setOptionsOp;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustOp changeTrustOp;\n  //       case ALLOW_TRUST:\n  //           AllowTrustOp allowTrustOp;\n  //       case ACCOUNT_MERGE:\n  //           AccountID destination;\n  //       case INFLATION:\n  //           void;\n  //       case MANAGE_DATA:\n  //           ManageDataOp manageDataOp;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceOp bumpSequenceOp;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferOp manageBuyOfferOp;\n  //       }\n  //       body;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Operation\", [[\"sourceAccount\", xdr.option(xdr.lookup(\"AccountId\"))], [\"body\", xdr.lookup(\"OperationBody\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum MemoType\n  //   {\n  //       MEMO_NONE = 0,\n  //       MEMO_TEXT = 1,\n  //       MEMO_ID = 2,\n  //       MEMO_HASH = 3,\n  //       MEMO_RETURN = 4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"MemoType\", {\n    memoNone: 0,\n    memoText: 1,\n    memoId: 2,\n    memoHash: 3,\n    memoReturn: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union Memo switch (MemoType type)\n  //   {\n  //   case MEMO_NONE:\n  //       void;\n  //   case MEMO_TEXT:\n  //       string text<28>;\n  //   case MEMO_ID:\n  //       uint64 id;\n  //   case MEMO_HASH:\n  //       Hash hash; // the hash of what to pull from the content server\n  //   case MEMO_RETURN:\n  //       Hash retHash; // the hash of the tx you are rejecting\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"Memo\", {\n    switchOn: xdr.lookup(\"MemoType\"),\n    switchName: \"type\",\n    switches: [[\"memoNone\", xdr.void()], [\"memoText\", \"text\"], [\"memoId\", \"id\"], [\"memoHash\", \"hash\"], [\"memoReturn\", \"retHash\"]],\n    arms: {\n      text: xdr.string(28),\n      id: xdr.lookup(\"Uint64\"),\n      hash: xdr.lookup(\"Hash\"),\n      retHash: xdr.lookup(\"Hash\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TimeBounds\n  //   {\n  //       TimePoint minTime;\n  //       TimePoint maxTime; // 0 here means no maxTime\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TimeBounds\", [[\"minTime\", xdr.lookup(\"TimePoint\")], [\"maxTime\", xdr.lookup(\"TimePoint\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   const MAX_OPS_PER_TX = 100;\n  //\n  // ===========================================================================\n  xdr.const(\"MAX_OPS_PER_TX\", 100);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Transaction\n  //   {\n  //       // account used to run the transaction\n  //       AccountID sourceAccount;\n  //   \n  //       // the fee the sourceAccount will pay\n  //       uint32 fee;\n  //   \n  //       // sequence number to consume in the account\n  //       SequenceNumber seqNum;\n  //   \n  //       // validity range (inclusive) for the last ledger close time\n  //       TimeBounds* timeBounds;\n  //   \n  //       Memo memo;\n  //   \n  //       Operation operations<MAX_OPS_PER_TX>;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Transaction\", [[\"sourceAccount\", xdr.lookup(\"AccountId\")], [\"fee\", xdr.lookup(\"Uint32\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"timeBounds\", xdr.option(xdr.lookup(\"TimeBounds\"))], [\"memo\", xdr.lookup(\"Memo\")], [\"operations\", xdr.varArray(xdr.lookup(\"Operation\"), xdr.lookup(\"MAX_OPS_PER_TX\"))], [\"ext\", xdr.lookup(\"TransactionExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (EnvelopeType type)\n  //       {\n  //       case ENVELOPE_TYPE_TX:\n  //           Transaction tx;\n  //           /* All other values of type are invalid */\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionSignaturePayloadTaggedTransaction\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeTx\", \"tx\"]],\n    arms: {\n      tx: xdr.lookup(\"Transaction\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionSignaturePayload\n  //   {\n  //       Hash networkId;\n  //       union switch (EnvelopeType type)\n  //       {\n  //       case ENVELOPE_TYPE_TX:\n  //           Transaction tx;\n  //           /* All other values of type are invalid */\n  //       }\n  //       taggedTransaction;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionSignaturePayload\", [[\"networkId\", xdr.lookup(\"Hash\")], [\"taggedTransaction\", xdr.lookup(\"TransactionSignaturePayloadTaggedTransaction\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionEnvelope\n  //   {\n  //       Transaction tx;\n  //       /* Each decorated signature is a signature over the SHA256 hash of\n  //        * a TransactionSignaturePayload */\n  //       DecoratedSignature signatures<20>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionEnvelope\", [[\"tx\", xdr.lookup(\"Transaction\")], [\"signatures\", xdr.varArray(xdr.lookup(\"DecoratedSignature\"), 20)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ClaimOfferAtom\n  //   {\n  //       // emitted to identify the offer\n  //       AccountID sellerID; // Account that owns the offer\n  //       int64 offerID;\n  //   \n  //       // amount and asset taken from the owner\n  //       Asset assetSold;\n  //       int64 amountSold;\n  //   \n  //       // amount and asset sent to the owner\n  //       Asset assetBought;\n  //       int64 amountBought;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ClaimOfferAtom\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")], [\"assetSold\", xdr.lookup(\"Asset\")], [\"amountSold\", xdr.lookup(\"Int64\")], [\"assetBought\", xdr.lookup(\"Asset\")], [\"amountBought\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum CreateAccountResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       CREATE_ACCOUNT_SUCCESS = 0, // account was created\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       CREATE_ACCOUNT_MALFORMED = -1,   // invalid destination\n  //       CREATE_ACCOUNT_UNDERFUNDED = -2, // not enough funds in source account\n  //       CREATE_ACCOUNT_LOW_RESERVE =\n  //           -3, // would create an account below the min reserve\n  //       CREATE_ACCOUNT_ALREADY_EXIST = -4 // account already exists\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"CreateAccountResultCode\", {\n    createAccountSuccess: 0,\n    createAccountMalformed: -1,\n    createAccountUnderfunded: -2,\n    createAccountLowReserve: -3,\n    createAccountAlreadyExist: -4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union CreateAccountResult switch (CreateAccountResultCode code)\n  //   {\n  //   case CREATE_ACCOUNT_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"CreateAccountResult\", {\n    switchOn: xdr.lookup(\"CreateAccountResultCode\"),\n    switchName: \"code\",\n    switches: [[\"createAccountSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum PaymentResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PAYMENT_SUCCESS = 0, // payment successfuly completed\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PAYMENT_MALFORMED = -1,          // bad input\n  //       PAYMENT_UNDERFUNDED = -2,        // not enough funds in source account\n  //       PAYMENT_SRC_NO_TRUST = -3,       // no trust line on source account\n  //       PAYMENT_SRC_NOT_AUTHORIZED = -4, // source not authorized to transfer\n  //       PAYMENT_NO_DESTINATION = -5,     // destination account does not exist\n  //       PAYMENT_NO_TRUST = -6,       // destination missing a trust line for asset\n  //       PAYMENT_NOT_AUTHORIZED = -7, // destination not authorized to hold asset\n  //       PAYMENT_LINE_FULL = -8,      // destination would go above their limit\n  //       PAYMENT_NO_ISSUER = -9       // missing issuer on asset\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"PaymentResultCode\", {\n    paymentSuccess: 0,\n    paymentMalformed: -1,\n    paymentUnderfunded: -2,\n    paymentSrcNoTrust: -3,\n    paymentSrcNotAuthorized: -4,\n    paymentNoDestination: -5,\n    paymentNoTrust: -6,\n    paymentNotAuthorized: -7,\n    paymentLineFull: -8,\n    paymentNoIssuer: -9\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union PaymentResult switch (PaymentResultCode code)\n  //   {\n  //   case PAYMENT_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"PaymentResult\", {\n    switchOn: xdr.lookup(\"PaymentResultCode\"),\n    switchName: \"code\",\n    switches: [[\"paymentSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum PathPaymentResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PATH_PAYMENT_SUCCESS = 0, // success\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PATH_PAYMENT_MALFORMED = -1,          // bad input\n  //       PATH_PAYMENT_UNDERFUNDED = -2,        // not enough funds in source account\n  //       PATH_PAYMENT_SRC_NO_TRUST = -3,       // no trust line on source account\n  //       PATH_PAYMENT_SRC_NOT_AUTHORIZED = -4, // source not authorized to transfer\n  //       PATH_PAYMENT_NO_DESTINATION = -5,     // destination account does not exist\n  //       PATH_PAYMENT_NO_TRUST = -6,           // dest missing a trust line for asset\n  //       PATH_PAYMENT_NOT_AUTHORIZED = -7,     // dest not authorized to hold asset\n  //       PATH_PAYMENT_LINE_FULL = -8,          // dest would go above their limit\n  //       PATH_PAYMENT_NO_ISSUER = -9,          // missing issuer on one asset\n  //       PATH_PAYMENT_TOO_FEW_OFFERS = -10,    // not enough offers to satisfy path\n  //       PATH_PAYMENT_OFFER_CROSS_SELF = -11,  // would cross one of its own offers\n  //       PATH_PAYMENT_OVER_SENDMAX = -12       // could not satisfy sendmax\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"PathPaymentResultCode\", {\n    pathPaymentSuccess: 0,\n    pathPaymentMalformed: -1,\n    pathPaymentUnderfunded: -2,\n    pathPaymentSrcNoTrust: -3,\n    pathPaymentSrcNotAuthorized: -4,\n    pathPaymentNoDestination: -5,\n    pathPaymentNoTrust: -6,\n    pathPaymentNotAuthorized: -7,\n    pathPaymentLineFull: -8,\n    pathPaymentNoIssuer: -9,\n    pathPaymentTooFewOffer: -10,\n    pathPaymentOfferCrossSelf: -11,\n    pathPaymentOverSendmax: -12\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct SimplePaymentResult\n  //   {\n  //       AccountID destination;\n  //       Asset asset;\n  //       int64 amount;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"SimplePaymentResult\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"PathPaymentResultSuccess\", [[\"offers\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"last\", xdr.lookup(\"SimplePaymentResult\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union PathPaymentResult switch (PathPaymentResultCode code)\n  //   {\n  //   case PATH_PAYMENT_SUCCESS:\n  //       struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       } success;\n  //   case PATH_PAYMENT_NO_ISSUER:\n  //       Asset noIssuer; // the asset that caused the error\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"PathPaymentResult\", {\n    switchOn: xdr.lookup(\"PathPaymentResultCode\"),\n    switchName: \"code\",\n    switches: [[\"pathPaymentSuccess\", \"success\"], [\"pathPaymentNoIssuer\", \"noIssuer\"]],\n    arms: {\n      success: xdr.lookup(\"PathPaymentResultSuccess\"),\n      noIssuer: xdr.lookup(\"Asset\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ManageSellOfferResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_SELL_OFFER_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_SELL_OFFER_MALFORMED = -1,     // generated offer would be invalid\n  //       MANAGE_SELL_OFFER_SELL_NO_TRUST = -2, // no trust line for what we're selling\n  //       MANAGE_SELL_OFFER_BUY_NO_TRUST = -3,  // no trust line for what we're buying\n  //       MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell\n  //       MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy\n  //       MANAGE_SELL_OFFER_LINE_FULL = -6,      // can't receive more of what it's buying\n  //       MANAGE_SELL_OFFER_UNDERFUNDED = -7,    // doesn't hold what it's trying to sell\n  //       MANAGE_SELL_OFFER_CROSS_SELF = -8,     // would cross an offer from the same user\n  //       MANAGE_SELL_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling\n  //       MANAGE_SELL_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying\n  //   \n  //       // update errors\n  //       MANAGE_SELL_OFFER_NOT_FOUND = -11, // offerID does not match an existing offer\n  //   \n  //       MANAGE_SELL_OFFER_LOW_RESERVE = -12 // not enough funds to create a new Offer\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ManageSellOfferResultCode\", {\n    manageSellOfferSuccess: 0,\n    manageSellOfferMalformed: -1,\n    manageSellOfferSellNoTrust: -2,\n    manageSellOfferBuyNoTrust: -3,\n    manageSellOfferSellNotAuthorized: -4,\n    manageSellOfferBuyNotAuthorized: -5,\n    manageSellOfferLineFull: -6,\n    manageSellOfferUnderfunded: -7,\n    manageSellOfferCrossSelf: -8,\n    manageSellOfferSellNoIssuer: -9,\n    manageSellOfferBuyNoIssuer: -10,\n    manageSellOfferNotFound: -11,\n    manageSellOfferLowReserve: -12\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ManageOfferEffect\n  //   {\n  //       MANAGE_OFFER_CREATED = 0,\n  //       MANAGE_OFFER_UPDATED = 1,\n  //       MANAGE_OFFER_DELETED = 2\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ManageOfferEffect\", {\n    manageOfferCreated: 0,\n    manageOfferUpdated: 1,\n    manageOfferDeleted: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (ManageOfferEffect effect)\n  //       {\n  //       case MANAGE_OFFER_CREATED:\n  //       case MANAGE_OFFER_UPDATED:\n  //           OfferEntry offer;\n  //       default:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"ManageOfferSuccessResultOffer\", {\n    switchOn: xdr.lookup(\"ManageOfferEffect\"),\n    switchName: \"effect\",\n    switches: [[\"manageOfferCreated\", \"offer\"], [\"manageOfferUpdated\", \"offer\"]],\n    arms: {\n      offer: xdr.lookup(\"OfferEntry\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct ManageOfferSuccessResult\n  //   {\n  //       // offers that got claimed while creating this offer\n  //       ClaimOfferAtom offersClaimed<>;\n  //   \n  //       union switch (ManageOfferEffect effect)\n  //       {\n  //       case MANAGE_OFFER_CREATED:\n  //       case MANAGE_OFFER_UPDATED:\n  //           OfferEntry offer;\n  //       default:\n  //           void;\n  //       }\n  //       offer;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ManageOfferSuccessResult\", [[\"offersClaimed\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"offer\", xdr.lookup(\"ManageOfferSuccessResultOffer\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union ManageSellOfferResult switch (ManageSellOfferResultCode code)\n  //   {\n  //   case MANAGE_SELL_OFFER_SUCCESS:\n  //       ManageOfferSuccessResult success;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ManageSellOfferResult\", {\n    switchOn: xdr.lookup(\"ManageSellOfferResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageSellOfferSuccess\", \"success\"]],\n    arms: {\n      success: xdr.lookup(\"ManageOfferSuccessResult\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ManageBuyOfferResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_BUY_OFFER_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_BUY_OFFER_MALFORMED = -1,     // generated offer would be invalid\n  //       MANAGE_BUY_OFFER_SELL_NO_TRUST = -2, // no trust line for what we're selling\n  //       MANAGE_BUY_OFFER_BUY_NO_TRUST = -3,  // no trust line for what we're buying\n  //       MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell\n  //       MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy\n  //       MANAGE_BUY_OFFER_LINE_FULL = -6,      // can't receive more of what it's buying\n  //       MANAGE_BUY_OFFER_UNDERFUNDED = -7,    // doesn't hold what it's trying to sell\n  //       MANAGE_BUY_OFFER_CROSS_SELF = -8,     // would cross an offer from the same user\n  //       MANAGE_BUY_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling\n  //       MANAGE_BUY_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying\n  //   \n  //       // update errors\n  //       MANAGE_BUY_OFFER_NOT_FOUND = -11, // offerID does not match an existing offer\n  //   \n  //       MANAGE_BUY_OFFER_LOW_RESERVE = -12 // not enough funds to create a new Offer\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ManageBuyOfferResultCode\", {\n    manageBuyOfferSuccess: 0,\n    manageBuyOfferMalformed: -1,\n    manageBuyOfferSellNoTrust: -2,\n    manageBuyOfferBuyNoTrust: -3,\n    manageBuyOfferSellNotAuthorized: -4,\n    manageBuyOfferBuyNotAuthorized: -5,\n    manageBuyOfferLineFull: -6,\n    manageBuyOfferUnderfunded: -7,\n    manageBuyOfferCrossSelf: -8,\n    manageBuyOfferSellNoIssuer: -9,\n    manageBuyOfferBuyNoIssuer: -10,\n    manageBuyOfferNotFound: -11,\n    manageBuyOfferLowReserve: -12\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ManageBuyOfferResult switch (ManageBuyOfferResultCode code)\n  //   {\n  //   case MANAGE_BUY_OFFER_SUCCESS:\n  //       ManageOfferSuccessResult success;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ManageBuyOfferResult\", {\n    switchOn: xdr.lookup(\"ManageBuyOfferResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageBuyOfferSuccess\", \"success\"]],\n    arms: {\n      success: xdr.lookup(\"ManageOfferSuccessResult\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum SetOptionsResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       SET_OPTIONS_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       SET_OPTIONS_LOW_RESERVE = -1,      // not enough funds to add a signer\n  //       SET_OPTIONS_TOO_MANY_SIGNERS = -2, // max number of signers already reached\n  //       SET_OPTIONS_BAD_FLAGS = -3,        // invalid combination of clear/set flags\n  //       SET_OPTIONS_INVALID_INFLATION = -4,      // inflation account does not exist\n  //       SET_OPTIONS_CANT_CHANGE = -5,            // can no longer change this option\n  //       SET_OPTIONS_UNKNOWN_FLAG = -6,           // can't set an unknown flag\n  //       SET_OPTIONS_THRESHOLD_OUT_OF_RANGE = -7, // bad value for weight/threshold\n  //       SET_OPTIONS_BAD_SIGNER = -8,             // signer cannot be masterkey\n  //       SET_OPTIONS_INVALID_HOME_DOMAIN = -9     // malformed home domain\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"SetOptionsResultCode\", {\n    setOptionsSuccess: 0,\n    setOptionsLowReserve: -1,\n    setOptionsTooManySigner: -2,\n    setOptionsBadFlag: -3,\n    setOptionsInvalidInflation: -4,\n    setOptionsCantChange: -5,\n    setOptionsUnknownFlag: -6,\n    setOptionsThresholdOutOfRange: -7,\n    setOptionsBadSigner: -8,\n    setOptionsInvalidHomeDomain: -9\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union SetOptionsResult switch (SetOptionsResultCode code)\n  //   {\n  //   case SET_OPTIONS_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"SetOptionsResult\", {\n    switchOn: xdr.lookup(\"SetOptionsResultCode\"),\n    switchName: \"code\",\n    switches: [[\"setOptionsSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ChangeTrustResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       CHANGE_TRUST_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       CHANGE_TRUST_MALFORMED = -1,     // bad input\n  //       CHANGE_TRUST_NO_ISSUER = -2,     // could not find issuer\n  //       CHANGE_TRUST_INVALID_LIMIT = -3, // cannot drop limit below balance\n  //                                        // cannot create with a limit of 0\n  //       CHANGE_TRUST_LOW_RESERVE =\n  //           -4, // not enough funds to create a new trust line,\n  //       CHANGE_TRUST_SELF_NOT_ALLOWED = -5  // trusting self is not allowed\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ChangeTrustResultCode\", {\n    changeTrustSuccess: 0,\n    changeTrustMalformed: -1,\n    changeTrustNoIssuer: -2,\n    changeTrustInvalidLimit: -3,\n    changeTrustLowReserve: -4,\n    changeTrustSelfNotAllowed: -5\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ChangeTrustResult switch (ChangeTrustResultCode code)\n  //   {\n  //   case CHANGE_TRUST_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ChangeTrustResult\", {\n    switchOn: xdr.lookup(\"ChangeTrustResultCode\"),\n    switchName: \"code\",\n    switches: [[\"changeTrustSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum AllowTrustResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       ALLOW_TRUST_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       ALLOW_TRUST_MALFORMED = -1,     // asset is not ASSET_TYPE_ALPHANUM\n  //       ALLOW_TRUST_NO_TRUST_LINE = -2, // trustor does not have a trustline\n  //                                       // source account does not require trust\n  //       ALLOW_TRUST_TRUST_NOT_REQUIRED = -3,\n  //       ALLOW_TRUST_CANT_REVOKE = -4,     // source account can't revoke trust,\n  //       ALLOW_TRUST_SELF_NOT_ALLOWED = -5 // trusting self is not allowed\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"AllowTrustResultCode\", {\n    allowTrustSuccess: 0,\n    allowTrustMalformed: -1,\n    allowTrustNoTrustLine: -2,\n    allowTrustTrustNotRequired: -3,\n    allowTrustCantRevoke: -4,\n    allowTrustSelfNotAllowed: -5\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union AllowTrustResult switch (AllowTrustResultCode code)\n  //   {\n  //   case ALLOW_TRUST_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"AllowTrustResult\", {\n    switchOn: xdr.lookup(\"AllowTrustResultCode\"),\n    switchName: \"code\",\n    switches: [[\"allowTrustSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum AccountMergeResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       ACCOUNT_MERGE_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       ACCOUNT_MERGE_MALFORMED = -1,       // can't merge onto itself\n  //       ACCOUNT_MERGE_NO_ACCOUNT = -2,      // destination does not exist\n  //       ACCOUNT_MERGE_IMMUTABLE_SET = -3,   // source account has AUTH_IMMUTABLE set\n  //       ACCOUNT_MERGE_HAS_SUB_ENTRIES = -4, // account has trust lines/offers\n  //       ACCOUNT_MERGE_SEQNUM_TOO_FAR = -5,  // sequence number is over max allowed\n  //       ACCOUNT_MERGE_DEST_FULL = -6        // can't add source balance to\n  //                                           // destination balance\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"AccountMergeResultCode\", {\n    accountMergeSuccess: 0,\n    accountMergeMalformed: -1,\n    accountMergeNoAccount: -2,\n    accountMergeImmutableSet: -3,\n    accountMergeHasSubEntry: -4,\n    accountMergeSeqnumTooFar: -5,\n    accountMergeDestFull: -6\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union AccountMergeResult switch (AccountMergeResultCode code)\n  //   {\n  //   case ACCOUNT_MERGE_SUCCESS:\n  //       int64 sourceAccountBalance; // how much got transfered from source account\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"AccountMergeResult\", {\n    switchOn: xdr.lookup(\"AccountMergeResultCode\"),\n    switchName: \"code\",\n    switches: [[\"accountMergeSuccess\", \"sourceAccountBalance\"]],\n    arms: {\n      sourceAccountBalance: xdr.lookup(\"Int64\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum InflationResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       INFLATION_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       INFLATION_NOT_TIME = -1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"InflationResultCode\", {\n    inflationSuccess: 0,\n    inflationNotTime: -1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct InflationPayout // or use PaymentResultAtom to limit types?\n  //   {\n  //       AccountID destination;\n  //       int64 amount;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"InflationPayout\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"amount\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union InflationResult switch (InflationResultCode code)\n  //   {\n  //   case INFLATION_SUCCESS:\n  //       InflationPayout payouts<>;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"InflationResult\", {\n    switchOn: xdr.lookup(\"InflationResultCode\"),\n    switchName: \"code\",\n    switches: [[\"inflationSuccess\", \"payouts\"]],\n    arms: {\n      payouts: xdr.varArray(xdr.lookup(\"InflationPayout\"), 2147483647)\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ManageDataResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_DATA_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_DATA_NOT_SUPPORTED_YET =\n  //           -1, // The network hasn't moved to this protocol change yet\n  //       MANAGE_DATA_NAME_NOT_FOUND =\n  //           -2, // Trying to remove a Data Entry that isn't there\n  //       MANAGE_DATA_LOW_RESERVE = -3, // not enough funds to create a new Data Entry\n  //       MANAGE_DATA_INVALID_NAME = -4 // Name not a valid string\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ManageDataResultCode\", {\n    manageDataSuccess: 0,\n    manageDataNotSupportedYet: -1,\n    manageDataNameNotFound: -2,\n    manageDataLowReserve: -3,\n    manageDataInvalidName: -4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ManageDataResult switch (ManageDataResultCode code)\n  //   {\n  //   case MANAGE_DATA_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ManageDataResult\", {\n    switchOn: xdr.lookup(\"ManageDataResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageDataSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum BumpSequenceResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       BUMP_SEQUENCE_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       BUMP_SEQUENCE_BAD_SEQ = -1 // `bumpTo` is not within bounds\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"BumpSequenceResultCode\", {\n    bumpSequenceSuccess: 0,\n    bumpSequenceBadSeq: -1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union BumpSequenceResult switch (BumpSequenceResultCode code)\n  //   {\n  //   case BUMP_SEQUENCE_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"BumpSequenceResult\", {\n    switchOn: xdr.lookup(\"BumpSequenceResultCode\"),\n    switchName: \"code\",\n    switches: [[\"bumpSequenceSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum OperationResultCode\n  //   {\n  //       opINNER = 0, // inner object result is valid\n  //   \n  //       opBAD_AUTH = -1,     // too few valid signatures / wrong network\n  //       opNO_ACCOUNT = -2,   // source account was not found\n  //       opNOT_SUPPORTED = -3, // operation not supported at this time\n  //       opTOO_MANY_SUBENTRIES = -4, // max number of subentries already reached\n  //       opEXCEEDED_WORK_LIMIT = -5  // operation did too much work\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"OperationResultCode\", {\n    opInner: 0,\n    opBadAuth: -1,\n    opNoAccount: -2,\n    opNotSupported: -3,\n    opTooManySubentry: -4,\n    opExceededWorkLimit: -5\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountResult createAccountResult;\n  //       case PAYMENT:\n  //           PaymentResult paymentResult;\n  //       case PATH_PAYMENT:\n  //           PathPaymentResult pathPaymentResult;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferResult manageSellOfferResult;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           ManageSellOfferResult createPassiveSellOfferResult;\n  //       case SET_OPTIONS:\n  //           SetOptionsResult setOptionsResult;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustResult changeTrustResult;\n  //       case ALLOW_TRUST:\n  //           AllowTrustResult allowTrustResult;\n  //       case ACCOUNT_MERGE:\n  //           AccountMergeResult accountMergeResult;\n  //       case INFLATION:\n  //           InflationResult inflationResult;\n  //       case MANAGE_DATA:\n  //           ManageDataResult manageDataResult;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceResult bumpSeqResult;\n  //       case MANAGE_BUY_OFFER:\n  //   \tManageBuyOfferResult manageBuyOfferResult;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"OperationResultTr\", {\n    switchOn: xdr.lookup(\"OperationType\"),\n    switchName: \"type\",\n    switches: [[\"createAccount\", \"createAccountResult\"], [\"payment\", \"paymentResult\"], [\"pathPayment\", \"pathPaymentResult\"], [\"manageSellOffer\", \"manageSellOfferResult\"], [\"createPassiveSellOffer\", \"createPassiveSellOfferResult\"], [\"setOption\", \"setOptionsResult\"], [\"changeTrust\", \"changeTrustResult\"], [\"allowTrust\", \"allowTrustResult\"], [\"accountMerge\", \"accountMergeResult\"], [\"inflation\", \"inflationResult\"], [\"manageDatum\", \"manageDataResult\"], [\"bumpSequence\", \"bumpSeqResult\"], [\"manageBuyOffer\", \"manageBuyOfferResult\"]],\n    arms: {\n      createAccountResult: xdr.lookup(\"CreateAccountResult\"),\n      paymentResult: xdr.lookup(\"PaymentResult\"),\n      pathPaymentResult: xdr.lookup(\"PathPaymentResult\"),\n      manageSellOfferResult: xdr.lookup(\"ManageSellOfferResult\"),\n      createPassiveSellOfferResult: xdr.lookup(\"ManageSellOfferResult\"),\n      setOptionsResult: xdr.lookup(\"SetOptionsResult\"),\n      changeTrustResult: xdr.lookup(\"ChangeTrustResult\"),\n      allowTrustResult: xdr.lookup(\"AllowTrustResult\"),\n      accountMergeResult: xdr.lookup(\"AccountMergeResult\"),\n      inflationResult: xdr.lookup(\"InflationResult\"),\n      manageDataResult: xdr.lookup(\"ManageDataResult\"),\n      bumpSeqResult: xdr.lookup(\"BumpSequenceResult\"),\n      manageBuyOfferResult: xdr.lookup(\"ManageBuyOfferResult\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union OperationResult switch (OperationResultCode code)\n  //   {\n  //   case opINNER:\n  //       union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountResult createAccountResult;\n  //       case PAYMENT:\n  //           PaymentResult paymentResult;\n  //       case PATH_PAYMENT:\n  //           PathPaymentResult pathPaymentResult;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferResult manageSellOfferResult;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           ManageSellOfferResult createPassiveSellOfferResult;\n  //       case SET_OPTIONS:\n  //           SetOptionsResult setOptionsResult;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustResult changeTrustResult;\n  //       case ALLOW_TRUST:\n  //           AllowTrustResult allowTrustResult;\n  //       case ACCOUNT_MERGE:\n  //           AccountMergeResult accountMergeResult;\n  //       case INFLATION:\n  //           InflationResult inflationResult;\n  //       case MANAGE_DATA:\n  //           ManageDataResult manageDataResult;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceResult bumpSeqResult;\n  //       case MANAGE_BUY_OFFER:\n  //   \tManageBuyOfferResult manageBuyOfferResult;\n  //       }\n  //       tr;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"OperationResult\", {\n    switchOn: xdr.lookup(\"OperationResultCode\"),\n    switchName: \"code\",\n    switches: [[\"opInner\", \"tr\"]],\n    arms: {\n      tr: xdr.lookup(\"OperationResultTr\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum TransactionResultCode\n  //   {\n  //       txSUCCESS = 0, // all operations succeeded\n  //   \n  //       txFAILED = -1, // one of the operations failed (none were applied)\n  //   \n  //       txTOO_EARLY = -2,         // ledger closeTime before minTime\n  //       txTOO_LATE = -3,          // ledger closeTime after maxTime\n  //       txMISSING_OPERATION = -4, // no operation was specified\n  //       txBAD_SEQ = -5,           // sequence number does not match source account\n  //   \n  //       txBAD_AUTH = -6,             // too few valid signatures / wrong network\n  //       txINSUFFICIENT_BALANCE = -7, // fee would bring account below reserve\n  //       txNO_ACCOUNT = -8,           // source account not found\n  //       txINSUFFICIENT_FEE = -9,     // fee is too small\n  //       txBAD_AUTH_EXTRA = -10,      // unused signatures attached to transaction\n  //       txINTERNAL_ERROR = -11       // an unknown error occured\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"TransactionResultCode\", {\n    txSuccess: 0,\n    txFailed: -1,\n    txTooEarly: -2,\n    txTooLate: -3,\n    txMissingOperation: -4,\n    txBadSeq: -5,\n    txBadAuth: -6,\n    txInsufficientBalance: -7,\n    txNoAccount: -8,\n    txInsufficientFee: -9,\n    txBadAuthExtra: -10,\n    txInternalError: -11\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (TransactionResultCode code)\n  //       {\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       default:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionResultResult\", {\n    switchOn: xdr.lookup(\"TransactionResultCode\"),\n    switchName: \"code\",\n    switches: [[\"txSuccess\", \"results\"], [\"txFailed\", \"results\"]],\n    arms: {\n      results: xdr.varArray(xdr.lookup(\"OperationResult\"), 2147483647)\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionResultExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionResult\n  //   {\n  //       int64 feeCharged; // actual fee charged for the transaction\n  //   \n  //       union switch (TransactionResultCode code)\n  //       {\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       default:\n  //           void;\n  //       }\n  //       result;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionResult\", [[\"feeCharged\", xdr.lookup(\"Int64\")], [\"result\", xdr.lookup(\"TransactionResultResult\")], [\"ext\", xdr.lookup(\"TransactionResultExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque Hash[32];\n  //\n  // ===========================================================================\n  xdr.typedef(\"Hash\", xdr.opaque(32));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque uint256[32];\n  //\n  // ===========================================================================\n  xdr.typedef(\"Uint256\", xdr.opaque(32));\n\n  // === xdr source ============================================================\n  //\n  //   typedef unsigned int uint32;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Uint32\", xdr.uint());\n\n  // === xdr source ============================================================\n  //\n  //   typedef int int32;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Int32\", xdr.int());\n\n  // === xdr source ============================================================\n  //\n  //   typedef unsigned hyper uint64;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Uint64\", xdr.uhyper());\n\n  // === xdr source ============================================================\n  //\n  //   typedef hyper int64;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Int64\", xdr.hyper());\n\n  // === xdr source ============================================================\n  //\n  //   enum CryptoKeyType\n  //   {\n  //       KEY_TYPE_ED25519 = 0,\n  //       KEY_TYPE_PRE_AUTH_TX = 1,\n  //       KEY_TYPE_HASH_X = 2\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"CryptoKeyType\", {\n    keyTypeEd25519: 0,\n    keyTypePreAuthTx: 1,\n    keyTypeHashX: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum PublicKeyType\n  //   {\n  //       PUBLIC_KEY_TYPE_ED25519 = KEY_TYPE_ED25519\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"PublicKeyType\", {\n    publicKeyTypeEd25519: 0\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum SignerKeyType\n  //   {\n  //       SIGNER_KEY_TYPE_ED25519 = KEY_TYPE_ED25519,\n  //       SIGNER_KEY_TYPE_PRE_AUTH_TX = KEY_TYPE_PRE_AUTH_TX,\n  //       SIGNER_KEY_TYPE_HASH_X = KEY_TYPE_HASH_X\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"SignerKeyType\", {\n    signerKeyTypeEd25519: 0,\n    signerKeyTypePreAuthTx: 1,\n    signerKeyTypeHashX: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union PublicKey switch (PublicKeyType type)\n  //   {\n  //   case PUBLIC_KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"PublicKey\", {\n    switchOn: xdr.lookup(\"PublicKeyType\"),\n    switchName: \"type\",\n    switches: [[\"publicKeyTypeEd25519\", \"ed25519\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union SignerKey switch (SignerKeyType type)\n  //   {\n  //   case SIGNER_KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   case SIGNER_KEY_TYPE_PRE_AUTH_TX:\n  //       /* SHA-256 Hash of TransactionSignaturePayload structure */\n  //       uint256 preAuthTx;\n  //   case SIGNER_KEY_TYPE_HASH_X:\n  //       /* Hash of random 256 bit preimage X */\n  //       uint256 hashX;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"SignerKey\", {\n    switchOn: xdr.lookup(\"SignerKeyType\"),\n    switchName: \"type\",\n    switches: [[\"signerKeyTypeEd25519\", \"ed25519\"], [\"signerKeyTypePreAuthTx\", \"preAuthTx\"], [\"signerKeyTypeHashX\", \"hashX\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\"),\n      preAuthTx: xdr.lookup(\"Uint256\"),\n      hashX: xdr.lookup(\"Uint256\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque Signature<64>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Signature\", xdr.varOpaque(64));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque SignatureHint[4];\n  //\n  // ===========================================================================\n  xdr.typedef(\"SignatureHint\", xdr.opaque(4));\n\n  // === xdr source ============================================================\n  //\n  //   typedef PublicKey NodeID;\n  //\n  // ===========================================================================\n  xdr.typedef(\"NodeId\", xdr.lookup(\"PublicKey\"));\n\n  // === xdr source ============================================================\n  //\n  //   struct Curve25519Secret\n  //   {\n  //           opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Curve25519Secret\", [[\"key\", xdr.opaque(32)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct Curve25519Public\n  //   {\n  //           opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Curve25519Public\", [[\"key\", xdr.opaque(32)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct HmacSha256Key\n  //   {\n  //           opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"HmacSha256Key\", [[\"key\", xdr.opaque(32)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct HmacSha256Mac\n  //   {\n  //           opaque mac[32];\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"HmacSha256Mac\", [[\"mac\", xdr.opaque(32)]]);\n}); // Automatically generated on 2019-04-30T12:43:38-07:00\n// DO NOT EDIT or your changes may be overwritten\n\n/* jshint maxstatements:2147483647  */\n/* jshint esnext:true  */\n\nexports.default = types;"]},"metadata":{},"sourceType":"script"}